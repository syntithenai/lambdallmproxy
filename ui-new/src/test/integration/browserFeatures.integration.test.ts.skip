/**
 * Browser Features Integration Tests
 * 
 * Tests full workflow: request → review → execute → history
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { renderHook, act, waitFor } from '@testing-library/react';
import { useBrowserFeatures } from '../../hooks/useBrowserFeatures';
import { 
  getExecutionHistory, 
  addExecutionHistoryEntry,
  clearExecutionHistory 
} from '../../components/ExecutionHistoryPanel';
import type { ExecutionHistoryEntry } from '../../services/clientTools/types';

describe('Browser Features Integration', () => {
  beforeEach(() => {
    // Clear all storage
    localStorage.clear();
    sessionStorage.clear();
    
    // Mock clipboard
    Object.defineProperty(navigator, 'clipboard', {
      value: {
        readText: vi.fn().mockResolvedValue('test clipboard'),
        writeText: vi.fn().mockResolvedValue(undefined)
      },
      writable: true,
      configurable: true
    });

    // Mock config to enable all features
    const mockConfig = {
      permissions: {
        javascript: true,
        storage_read: true,
        storage_write: true,
        clipboard_read: true,
        clipboard_write: true,
        notification: true,
        geolocation: true,
        file_read: true,
        screenshot: true,
        dom_query: true,
        dom_manipulate: true
      },
      codeReviewMode: 'timeout' as const,
      autoApproveTimeout: 1 // 1 second for testing
    };

    localStorage.setItem('browser_features_config', JSON.stringify(mockConfig));
  });

  afterEach(() => {
    vi.clearAllMocks();
    clearExecutionHistory();
  });

  describe('Full Workflow: Low-Risk Feature', () => {
    it('should execute storage_read without code review (timeout mode)', async () => {
      // Pre-populate storage
      localStorage.setItem('test_key', 'test_value');

      const { result } = renderHook(() => useBrowserFeatures());

      // Simulate tool call
      const toolCall = {
        id: 'call_123',
        function: {
          name: 'execute_browser_feature',
          arguments: JSON.stringify({
            feature: 'storage_read',
            storage_key: 'test_key',
            description: 'Read test key'
          })
        }
      };

      let executionResult: any;

      await act(async () => {
        executionResult = await result.current.handleBrowserFeatureCall(toolCall);
      });

      // Should execute without review in timeout mode
      expect(executionResult.success).toBe(true);
      expect(executionResult.result).toBe('test_value');

      // Should be logged in history
      const history = getExecutionHistory();
      expect(history.length).toBe(1);
      expect(history[0].feature).toBe('storage_read');
      expect(history[0].success).toBe(true);
    });
  });

  describe('Full Workflow: High-Risk Feature with Review', () => {
    it('should queue high-risk feature for code review', async () => {
      // Set to always review mode
      const config = JSON.parse(localStorage.getItem('browser_features_config')!);
      config.codeReviewMode = 'always';
      localStorage.setItem('browser_features_config', JSON.stringify(config));

      const { result } = renderHook(() => useBrowserFeatures());

      const toolCall = {
        id: 'call_456',
        function: {
          name: 'execute_browser_feature',
          arguments: JSON.stringify({
            feature: 'javascript',
            code: 'return 42',
            description: 'Calculate answer'
          })
        }
      };

      // Start execution (will be queued)
      let executionPromise: Promise<any>;

      act(() => {
        executionPromise = result.current.handleBrowserFeatureCall(toolCall);
      });

      // Should show code review dialog
      await waitFor(() => {
        expect(result.current.showCodeReview).toBe(true);
        expect(result.current.codeReviewRequest).toBeDefined();
        expect(result.current.codeReviewRequest?.feature).toBe('javascript');
      });

      // Approve the code
      await act(async () => {
        await result.current.approveCodeReview();
      });

      // Wait for execution to complete
      const executionResult = await executionPromise!;

      // Should execute successfully
      expect(executionResult.success).toBe(true);
      expect(executionResult.result).toBe(42);

      // Should be logged in history
      const history = getExecutionHistory();
      expect(history.length).toBe(1);
      expect(history[0].feature).toBe('javascript');
      expect(history[0].success).toBe(true);
      expect(history[0].code).toBe('return 42');
    });

    it('should handle code rejection', async () => {
      const config = JSON.parse(localStorage.getItem('browser_features_config')!);
      config.codeReviewMode = 'always';
      localStorage.setItem('browser_features_config', JSON.stringify(config));

      const { result } = renderHook(() => useBrowserFeatures());

      const toolCall = {
        id: 'call_789',
        function: {
          name: 'execute_browser_feature',
          arguments: JSON.stringify({
            feature: 'javascript',
            code: 'console.log("test")',
            description: 'Test code'
          })
        }
      };

      let executionPromise: Promise<any>;

      act(() => {
        executionPromise = result.current.handleBrowserFeatureCall(toolCall);
      });

      // Wait for code review dialog
      await waitFor(() => {
        expect(result.current.showCodeReview).toBe(true);
      });

      // Reject the code
      act(() => {
        result.current.rejectCodeReview();
      });

      // Wait for execution to complete with rejection
      const executionResult = await executionPromise!;

      // Should fail with rejection message
      expect(executionResult.success).toBe(false);
      expect(executionResult.error).toContain('rejected');

      // Should not be logged in history (rejected before execution)
      const history = getExecutionHistory();
      expect(history.length).toBe(0);
    });

    it('should execute with edited code', async () => {
      const config = JSON.parse(localStorage.getItem('browser_features_config')!);
      config.codeReviewMode = 'always';
      localStorage.setItem('browser_features_config', JSON.stringify(config));

      const { result } = renderHook(() => useBrowserFeatures());

      const toolCall = {
        id: 'call_abc',
        function: {
          name: 'execute_browser_feature',
          arguments: JSON.stringify({
            feature: 'javascript',
            code: 'return 1 + 1',
            description: 'Simple math'
          })
        }
      };

      let executionPromise: Promise<any>;

      act(() => {
        executionPromise = result.current.handleBrowserFeatureCall(toolCall);
      });

      await waitFor(() => {
        expect(result.current.showCodeReview).toBe(true);
      });

      // Approve with edited code
      await act(async () => {
        await result.current.approveCodeReview('return 2 + 2');
      });

      const executionResult = await executionPromise!;

      // Should execute edited code
      expect(executionResult.success).toBe(true);
      expect(executionResult.result).toBe(4); // 2 + 2, not 1 + 1

      // History should show edited flag
      const history = getExecutionHistory();
      expect(history[0].edited).toBe(true);
      expect(history[0].code).toBe('return 2 + 2');
    });
  });

  describe('Session Approvals', () => {
    it('should skip review for session-approved code', async () => {
      const config = JSON.parse(localStorage.getItem('browser_features_config')!);
      config.codeReviewMode = 'always';
      localStorage.setItem('browser_features_config', JSON.stringify(config));

      const { result } = renderHook(() => useBrowserFeatures());

      const toolCall = {
        id: 'call_def',
        function: {
          name: 'execute_browser_feature',
          arguments: JSON.stringify({
            feature: 'storage_read',
            storage_key: 'key',
            description: 'Read key'
          })
        }
      };

      // First execution - requires review
      let promise1: Promise<any>;

      act(() => {
        promise1 = result.current.handleBrowserFeatureCall(toolCall);
      });

      await waitFor(() => {
        expect(result.current.showCodeReview).toBe(true);
      });

      // Approve with "always allow"
      act(() => {
        result.current.alwaysAllowCodeReview();
      });

      await promise1!;

      // Second execution with same code - should skip review
      const promise2 = act(async () => {
        return await result.current.handleBrowserFeatureCall(toolCall);
      });

      // Should not show code review (already approved for session)
      expect(result.current.showCodeReview).toBe(false);

      const result2 = await promise2;
      expect(result2.success).toBe(true);
    });
  });

  describe('Execution History Tracking', () => {
    it('should track successful executions', async () => {
      const entry: ExecutionHistoryEntry = {
        id: '123',
        feature: 'storage_read',
        description: 'Read test',
        timestamp: Date.now(),
        duration: 10,
        success: true,
        code: undefined,
        args: { storage_key: 'test' },
        result: 'value',
        edited: false
      };

      addExecutionHistoryEntry(entry);

      const history = getExecutionHistory();
      expect(history.length).toBe(1);
      expect(history[0].id).toBe('123');
      expect(history[0].success).toBe(true);
    });

    it('should track failed executions', async () => {
      const entry: ExecutionHistoryEntry = {
        id: '456',
        feature: 'javascript',
        description: 'Bad code',
        timestamp: Date.now(),
        duration: 5,
        success: false,
        code: 'invalid code',
        args: { code: 'invalid code' },
        result: undefined,
        error: 'Syntax error',
        edited: false
      };

      addExecutionHistoryEntry(entry);

      const history = getExecutionHistory();
      expect(history[0].success).toBe(false);
      expect(history[0].error).toBe('Syntax error');
    });

    it('should limit history to 100 entries', () => {
      clearExecutionHistory();

      // Add 150 entries
      for (let i = 0; i < 150; i++) {
        addExecutionHistoryEntry({
          id: `entry_${i}`,
          feature: 'storage_read',
          description: `Entry ${i}`,
          timestamp: Date.now() + i,
          duration: 1,
          success: true,
          args: {},
          result: i,
          edited: false
        });
      }

      const history = getExecutionHistory();
      expect(history.length).toBe(100);
      
      // Should keep most recent
      expect(history[0].id).toBe('entry_149');
      expect(history[99].id).toBe('entry_50');
    });

    it('should clear all history', () => {
      // Add some entries
      addExecutionHistoryEntry({
        id: '1',
        feature: 'storage_read',
        description: 'Test',
        timestamp: Date.now(),
        duration: 1,
        success: true,
        args: {},
        result: null,
        edited: false
      });

      expect(getExecutionHistory().length).toBe(1);

      clearExecutionHistory();

      expect(getExecutionHistory().length).toBe(0);
    });
  });

  describe('Feature Permission Checks', () => {
    it('should fail when feature is disabled', async () => {
      // Disable javascript feature
      const config = JSON.parse(localStorage.getItem('browser_features_config')!);
      config.permissions.javascript = false;
      localStorage.setItem('browser_features_config', JSON.stringify(config));

      const { result } = renderHook(() => useBrowserFeatures());

      const toolCall = {
        id: 'call_disabled',
        function: {
          name: 'execute_browser_feature',
          arguments: JSON.stringify({
            feature: 'javascript',
            code: 'return 42',
            description: 'Test'
          })
        }
      };

      const executionResult = await act(async () => {
        return await result.current.handleBrowserFeatureCall(toolCall);
      });

      expect(executionResult.success).toBe(false);
      expect(executionResult.error).toContain('not enabled');
    });
  });

  describe('Complex Multi-Step Workflow', () => {
    it('should handle multiple executions with mixed success', async () => {
      const { result } = renderHook(() => useBrowserFeatures());

      // Step 1: Write to storage (should succeed)
      const call1 = {
        id: 'call_1',
        function: {
          name: 'execute_browser_feature',
          arguments: JSON.stringify({
            feature: 'storage_write',
            storage_key: 'data',
            storage_value: 'test_data',
            description: 'Store data'
          })
        }
      };

      const result1 = await act(async () => {
        return await result.current.handleBrowserFeatureCall(call1);
      });

      expect(result1.success).toBe(true);

      // Step 2: Read from storage (should succeed)
      const call2 = {
        id: 'call_2',
        function: {
          name: 'execute_browser_feature',
          arguments: JSON.stringify({
            feature: 'storage_read',
            storage_key: 'data',
            description: 'Read data'
          })
        }
      };

      const result2 = await act(async () => {
        return await result.current.handleBrowserFeatureCall(call2);
      });

      expect(result2.success).toBe(true);
      expect(result2.result).toBe('test_data');

      // Step 3: Write to clipboard (should succeed)
      const call3 = {
        id: 'call_3',
        function: {
          name: 'execute_browser_feature',
          arguments: JSON.stringify({
            feature: 'clipboard_write',
            clipboard_text: 'copied text',
            description: 'Copy to clipboard'
          })
        }
      };

      const result3 = await act(async () => {
        return await result.current.handleBrowserFeatureCall(call3);
      });

      expect(result3.success).toBe(true);

      // Check history has all 3 executions
      const history = getExecutionHistory();
      expect(history.length).toBe(3);
      expect(history.every(e => e.success)).toBe(true);
    });
  });
});
