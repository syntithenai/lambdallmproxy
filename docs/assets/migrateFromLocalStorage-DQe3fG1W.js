import{b0 as a,b1 as u,b2 as d}from"./index-Ba9w6Zmy.js";class I{currentUserId=null;setUserId(e){this.currentUserId=e,console.log("[UnifiedStorage] User ID set:",e)}getCurrentUserId(){if(!this.currentUserId)throw new Error("Authentication required for all persistence operations");return this.currentUserId}async save(e,t){const s=this.getCurrentUserId(),r={...t,userId:s,updatedAt:Date.now()};t.createdAt||(r.createdAt=Date.now()),r.id||(r.id=crypto.randomUUID());const n=a[e];if(!n)throw new Error(`Unknown data type: ${e}`);await n.put(r),console.log(`[UnifiedStorage] Saved ${e}:`,r.id)}async get(e,t){const s=this.getCurrentUserId(),r=a[e];if(!r)throw new Error(`Unknown data type: ${e}`);const n=await r.get(t);return n&&n.userId!==s?(console.warn(`[UnifiedStorage] Access denied to ${e}:${t} (owned by ${n.userId})`),null):n||null}async query(e,t){const s=this.getCurrentUserId(),r=a[e];if(!r)throw new Error(`Unknown data type: ${e}`);let n;return t?.projectId?n=r.where("[userId+projectId]").equals([s,t.projectId]):t?.status&&e==="plans"?n=r.where("[userId+status]").equals([s,t.status]):t?.conversationId&&e==="chatHistory"?n=r.where("[userId+conversationId]").equals([s,t.conversationId]):t?.source&&e==="images"?n=r.where("[userId+source]").equals([s,t.source]):t?.quizId&&(e==="quizProgress"||e==="quizAnalytics")?n=r.where("[userId+quizId]").equals([s,t.quizId]):n=r.where("userId").equals(s),await n.toArray()}async delete(e,t){const s=this.getCurrentUserId(),r=a[e];if(!r)throw new Error(`Unknown data type: ${e}`);const n=await r.get(t);if(n&&n.userId!==s)throw new Error("Cannot delete record owned by another user");await r.delete(t),console.log(`[UnifiedStorage] Deleted ${e}:`,t)}async bulkDelete(e,t){const s=this.getCurrentUserId(),r=a[e];if(!r)throw new Error(`Unknown data type: ${e}`);const n=await r.bulkGet(t);for(const o of n)if(o&&o.userId!==s)throw new Error("Cannot delete records owned by another user");await r.bulkDelete(t),console.log(`[UnifiedStorage] Bulk deleted ${t.length} ${e} records`)}async saveUIState(e,t){const s=this.getCurrentUserId(),r=`uiState_${e}`,n=a[r];if(!n)throw new Error(`Unknown UI state type: ${e}`);await n.put({userId:s,...t,updatedAt:Date.now()}),console.log("[UnifiedStorage] Saved UI state:",e)}async getUIState(e){const t=this.getCurrentUserId(),s=`uiState_${e}`,r=a[s];if(!r)throw new Error(`Unknown UI state type: ${e}`);return await r.get(t)}async cleanupOldFeedItems(){const e=this.getCurrentUserId(),t=await a.feedItems.where("userId").equals(e).reverse().sortBy("createdAt");if(t.length>100){const r=t.slice(100).map(n=>n.id);await a.feedItems.bulkDelete(r),console.log(`[UnifiedStorage] Cleaned up ${r.length} old feed items`)}}async isImageOrphaned(e){const t=this.getCurrentUserId();return await a.snippets.where("userId").equals(t).filter(o=>o.content.includes(e)).count()>0||await a.feedItems.where("userId").equals(t).filter(o=>o.image?.includes(e)??!1).count()>0?!1:await a.chatHistory.where("userId").equals(t).filter(o=>o.content.includes(e)).count()===0}async cleanupOrphanedImages(){const e=this.getCurrentUserId(),t=await a.images.where("userId").equals(e).toArray();for(const s of t)await this.isImageOrphaned(s.id)&&(await a.images.delete(s.id),console.log("[UnifiedStorage] Deleted orphaned image:",s.id))}}const l=new I;function h(){return localStorage.getItem("localStorage_migration_completed")==="true"}function w(){localStorage.setItem("localStorage_migration_completed","true")}async function v(i){if(h()){console.log("[Migration] Already completed, skipping");return}console.log("[Migration] Starting localStorage migration for",i);try{await m(i),await f(i),w(),console.log("[Migration] ✅ Completed successfully")}catch(e){throw console.error("[Migration] ❌ Failed:",e),e}}async function m(i){console.log("[Migration] Migrating settings...");const e=u(i),t=localStorage.getItem("settings");if(t)try{const o=JSON.parse(t);Object.assign(e,{language:o.language||e.language,theme:o.theme||e.theme,providers:o.providers||e.providers,defaultProvider:o.defaultProvider}),console.log("[Migration] ✅ Migrated main settings")}catch(o){console.error("[Migration] ⚠️ Failed to parse old settings:",o)}const s={continuousVoice_hotword:o=>{e.voice.hotword=o},continuousVoice_sensitivity:o=>{e.voice.sensitivity=parseFloat(o)},continuousVoice_speechTimeout:o=>{e.voice.speechTimeout=parseFloat(o)},continuousVoice_conversationTimeout:o=>{e.voice.conversationTimeout=parseInt(o)},voice_useLocalWhisper:o=>{e.voice.useLocalWhisper=o==="true"},voice_localWhisperUrl:o=>{e.voice.localWhisperUrl=o}};for(const[o,g]of Object.entries(s)){const c=localStorage.getItem(o);c!==null&&g(c)}console.log("[Migration] ✅ Migrated voice settings");const r=localStorage.getItem("proxy_settings");if(r)try{const o=JSON.parse(r);Object.assign(e.proxy,{enabled:o.enabled!==!1,username:o.username||"",password:o.password||"",useServerProxy:o.useServerProxy||!1}),console.log("[Migration] ✅ Migrated proxy settings")}catch(o){console.error("[Migration] ⚠️ Failed to parse proxy settings:",o)}await d(e),console.log("[Migration] ✅ Saved unified settings to IndexedDB");const n=["settings","proxy_settings","continuousVoice_hotword","continuousVoice_sensitivity","continuousVoice_speechTimeout","continuousVoice_conversationTimeout","voice_useLocalWhisper","voice_localWhisperUrl"];for(const o of n)localStorage.removeItem(o);console.log("[Migration] ✅ Cleaned up localStorage")}async function f(i){console.log("[Migration] Migrating UI state...");const e=localStorage.getItem("recent-tags");if(e)try{const s=JSON.parse(e);await l.saveUIState("recentTags",{tags:s}),localStorage.removeItem("recent-tags"),console.log("[Migration] ✅ Migrated recent tags")}catch(s){console.error("[Migration] ⚠️ Failed to migrate recent tags:",s)}const t=localStorage.getItem("lastActiveChat");t&&(await l.saveUIState("lastActiveChat",{conversationId:t}),localStorage.removeItem("lastActiveChat"),console.log("[Migration] ✅ Migrated last active chat")),console.log("[Migration] UI state migration complete")}export{v as migrateFromLocalStorage};
