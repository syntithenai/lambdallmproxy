<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Search</title>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", Arial, sans-serif;
            background-color: #f4f4f9;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .form-container {
            background-color: #fff;
            padding: 12px 20px;
            border-bottom: 2px solid #e0e0e0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            flex-shrink: 0;
        }

        h1 {
            color: #333;
            margin: 0;
            font-size: 1.2rem;
            display: inline-block;
            margin-right: 20px;
        }

        .form-row {
            display: flex;
            align-items: flex-start;
            gap: 15px;
            flex-wrap: wrap;
        }

        .form-row-top {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 12px;
        }

        .form-row-bottom {
            width: 100%;
        }

        .form-row-bottom .form-group {
            width: 100%;
        }

        .form-row-bottom label {
            display: block;
            margin-bottom: 6px;
        }

        label {
            color: #555;
            font-weight: 500;
            font-size: 0.9rem;
            margin: 0;
        }

        .form-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .form-group.query-group {
            flex: 1;
            min-width: 300px;
        }

        input[type="text"],
        textarea,
        select {
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 0.9rem;
            box-sizing: border-box;
        }

        #model {
            width: 180px;
        }

        #prompt {
            flex: 1;
            resize: vertical;
            height: auto;
            min-height: 200px;
            width: 100%;
        }

        .search-mode-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .search-mode-option {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.85rem;
            white-space: nowrap;
        }

        .search-mode-option input[type="radio"] {
            margin: 0;
        }

        button[type="submit"] {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
        }

        button[type="submit"]:hover:not(:disabled) {
            background: #0056b3;
        }

        button[type="submit"]:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .response-container {
            flex: 1;
            margin: 20px;
            padding: 20px;
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
            display: none;
        }

        .response-container.loading {
            color: #6c757d;
            font-style: italic;
            text-align: center;
        }

        .response-container.response-success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .response-container.response-error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .response-container pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: inherit;
            margin: 0;
        }

        /* Enhanced response styles */
        .answer-content {
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .search-summaries {
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }

        .search-summaries h3 {
            margin: 0 0 15px 0;
            color: #0056b3;
            font-size: 1.1em;
        }

        .search-summary {
            margin-bottom: 10px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .search-summary:last-child {
            border-bottom: none;
        }

        .response-links {
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 8px;
            border-left: 4px solid #28a745;
        }

        .response-links h3 {
            margin: 0 0 15px 0;
            color: #1e7e34;
            font-size: 1.1em;
        }

        .link-item {
            margin-bottom: 12px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .link-item:last-child {
            border-bottom: none;
        }

        .link-item a {
            color: #007bff;
            text-decoration: none;
            font-weight: 500;
        }

        .link-item a:hover {
            text-decoration: underline;
        }

        .link-item small {
            color: #6c757d;
            font-size: 0.9em;
        }

        .debug-info {
            margin: 20px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
        }

        .debug-info summary {
            cursor: pointer;
            font-weight: 500;
            color: #6c757d;
            margin-bottom: 10px;
        }

        .debug-info pre {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 0.8em;
            max-height: 300px;
            overflow-y: auto;
        }

        /* New styles for search iterations and results */
        .search-iterations {
            margin: 15px 0;
            border: 1px solid #e9ecef;
            border-radius: 4px;
        }

        .iteration-section {
            margin: 5px 0;
        }

        .iteration-section summary {
            padding: 10px;
            background: #f8f9fa;
            cursor: pointer;
            border-radius: 4px;
            font-weight: 500;
        }

        .iteration-section[open] summary {
            border-bottom: 1px solid #e9ecef;
            border-radius: 4px 4px 0 0;
        }

        .search-list {
            margin: 10px 0;
            padding-left: 20px;
        }

        .search-list li {
            margin: 5px 0;
            font-size: 0.95em;
        }

        .search-results-section {
            margin: 15px 0;
            border: 1px solid #e9ecef;
            border-radius: 4px;
        }

        .search-results-section summary {
            padding: 10px;
            background: #f8f9fa;
            cursor: pointer;
            border-radius: 4px;
            font-weight: 500;
        }

        .search-results-section[open] summary {
            border-bottom: 1px solid #e9ecef;
            border-radius: 4px 4px 0 0;
        }

        .result-item {
            padding: 10px;
            border-bottom: 1px solid #f1f1f1;
        }

        .result-item:last-child {
            border-bottom: none;
        }

        .result-item h4 {
            margin: 0 0 5px 0;
            font-size: 1.1em;
        }

        .result-item h4 a {
            color: #0066cc;
            text-decoration: none;
        }

        .result-item h4 a:hover {
            text-decoration: underline;
        }

        .result-description {
            margin: 5px 0;
            color: #333;
            font-size: 0.95em;
        }

        .result-url {
            margin: 5px 0 0 0;
            color: #6c757d;
            font-size: 0.85em;
        }

        .advanced-toggle {
            margin: 15px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #e9ecef;
        }

        .advanced-toggle label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-weight: 500;
            color: #495057;
        }

        .advanced-toggle input[type="checkbox"] {
            margin-right: 8px;
        }

        .advanced-panel {
            margin: 15px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
            transition: all 0.3s ease;
        }

        .advanced-panel h3 {
            margin: 0 0 15px 0;
            color: #495057;
            font-size: 1.1em;
            border-bottom: 2px solid #dee2e6;
            padding-bottom: 8px;
        }

        .advanced-panel h3:not(:first-child) {
            margin-top: 25px;
        }

        .advanced-panel .form-group {
            margin-bottom: 20px;
        }

        .advanced-panel label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #495057;
        }

        .advanced-panel textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
            resize: vertical;
            min-height: 60px;
            box-sizing: border-box;
        }

        .advanced-panel textarea:focus {
            outline: none;
            border-color: #80bdff;
            box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25);
        }

        /* Settings Dialog Styles */
        .settings-button {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
        }

        .settings-button:hover {
            background: #0056b3;
        }

        /* Login Button Styles */
        .login-button {
            position: fixed;
            top: 20px;
            right: 80px;
            height: 40px;
            border-radius: 20px;
            background: #4285f4;
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 16px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            transition: background-color 0.3s;
        }

        .login-button:hover {
            background: #3367d6;
        }

        .login-button.logged-in {
            background: #34a853;
            padding: 0;
            width: 120px;
        }

        .profile-container {
            display: flex;
            align-items: center;
            padding: 0 12px;
            width: 100%;
        }

        .profile-picture {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .logout-text {
            font-size: 12px;
        }

        .settings-dialog {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1001;
        }

        .settings-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 12px;
            padding: 2rem;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #dee2e6;
        }

        .settings-header h2 {
            margin: 0;
            color: #333;
        }

        .close-button {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-button:hover {
            color: #333;
        }

        .settings-section {
            margin-bottom: 2rem;
        }

        .settings-section h3 {
            margin: 0 0 1rem 0;
            color: #555;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.5rem;
        }

        /* Settings form styles */
        .settings-dialog .form-group {
            display: block;
            margin-bottom: 1.5rem;
        }

        .settings-dialog .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #495057;
        }

        .settings-dialog textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
            resize: vertical;
            min-height: 60px;
            box-sizing: border-box;
        }

        .settings-dialog textarea:focus {
            outline: none;
            border-color: #80bdff;
            box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25);
        }

        .settings-separator {
            height: 1px;
            background: linear-gradient(to right, transparent, #dee2e6, transparent);
            margin: 2rem 0;
            position: relative;
        }

        .settings-separator::before {
            content: "Templates";
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 0 1rem;
            color: #6c757d;
            font-size: 0.9em;
            font-weight: 500;
        }

        /* Auth banner */
        .auth-banner {
            margin: 10px 0 15px 0;
            padding: 12px 14px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            background: #f8f9fa;
            color: #495057;
            display: none;
        }
        .auth-banner.info { border-left: 4px solid #17a2b8; }
        .auth-banner.warn { border-left: 4px solid #ffc107; }
        .auth-banner.ok { border-left: 4px solid #28a745; }
        .auth-banner.error { border-left: 4px solid #dc3545; }
        .auth-banner small { color: #6c757d; }
    </style>
</head>
<body>

<!-- Login Button -->
<button class="login-button" id="login-btn">
    <span id="login-text">Sign in with Google</span>
</button>

<!-- Google Button Fallback (rendered by GIS) -->
<div id="google-button-container" style="position: fixed; top: 70px; right: 20px; z-index: 1000;"></div>

<!-- Settings Button -->
<button class="settings-button" id="settings-btn" title="Settings">⚙️</button>

<!-- Settings Dialog -->
<div class="settings-dialog" id="settings-dialog">
    <div class="settings-content">
        <div class="settings-header">
            <h2>Settings</h2>
            <button class="close-button" id="close-settings">×</button>
        </div>
        
        <div class="settings-section">
            <h3>API Keys</h3>
            <div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <label for="openai_api_key">OpenAI API Key:</label>
                    <button type="button" id="openai_help_button" style="background: #007bff; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; font-size: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center; line-height: 1;" title="Get OpenAI API Key">?</button>
                </div>
                <div style="position: relative;">
                    <input type="text" id="openai_api_key" name="openai_api_key" placeholder="sk-...">
                    <small id="openai_api_key_status" style="color: #666; font-size: 0.85em; margin-top: 4px; display: block;"></small>
                    <button type="button" id="clear_openai_api_key" style="position: absolute; right: 8px; top: 8px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 4px 8px; font-size: 0.8em; color: #6c757d; cursor: pointer; display: none;" title="Clear saved API key">Clear</button>
                </div>
            </div>
            <div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <label for="groq_api_key">Groq API Key:</label>
                    <button type="button" id="groq_help_button" style="background: #007bff; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; font-size: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center; line-height: 1;" title="Get Groq API Key">?</button>
                </div>
                <div style="position: relative;">
                    <input type="text" id="groq_api_key" name="groq_api_key" placeholder="gsk_...">
                    <small id="groq_api_key_status" style="color: #666; font-size: 0.85em; margin-top: 4px; display: block;"></small>
                    <button type="button" id="clear_groq_api_key" style="position: absolute; right: 8px; top: 8px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 4px 8px; font-size: 0.8em; color: #6c757d; cursor: pointer; display: none;" title="Clear saved API key">Clear</button>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="form-container">
    <form id="llm-form">
        <input type="hidden" id="access_secret" name="access_secret" value="FUCKoffNOW2">
        <div id="auth-banner" class="auth-banner"></div>
        
        <div class="form-row-top">
            <h1>AI Search</h1>
            
            <div class="form-group">
                <label for="model">Model:</label>
                <select id="model" name="model">
                    <optgroup label="Groq Models" id="groq-models">
                        <option value="groq:llama-3.1-8b-instant" selected>Llama 3.1 8B Instant (Fastest)</option>
                        <option value="groq:llama-3.1-70b-versatile">Llama 3.1 70B Versatile</option>
                        <option value="groq:llama-3.1-405b-reasoning">Llama 3.1 405B Reasoning</option>
                        <option value="groq:mixtral-8x7b-32768">Mixtral 8x7B</option>
                    </optgroup>
                    <optgroup label="OpenAI Models" id="openai-models">
                        <option value="openai:gpt-4o">GPT-4o</option>
                        <option value="openai:gpt-4o-mini">GPT-4o Mini</option>
                        <option value="openai:gpt-4">GPT-4</option>
                        <option value="openai:gpt-3.5-turbo">GPT-3.5 Turbo</option>
                    </optgroup>
                </select>
            </div>

            <div class="form-group">
                <label>Search:</label>
                <div class="search-mode-group">
                    <div class="search-mode-option">
                        <input type="radio" id="search_auto" name="search_mode" value="auto" checked>
                        <label for="search_auto">Auto</label>
                    </div>
                    <div class="search-mode-option">
                        <input type="radio" id="search_force" name="search_mode" value="search">
                        <label for="search_force">Search</label>
                    </div>
                    <div class="search-mode-option">
                        <input type="radio" id="search_skip" name="search_mode" value="direct">
                        <label for="search_skip">Direct</label>
                    </div>
                </div>
            </div>
            
            <button type="submit" id="submit-btn" disabled>Sign in or add an API key</button>
        </div>

        <div class="form-row-bottom">
            <div class="form-group">
                <label for="prompt">Query:</label>
                <textarea id="prompt" name="prompt" rows="10" required placeholder="Enter your question here...">how old is the first child of the king of spain</textarea>
            </div>
        </div>
    </form>
</div>

<div id="response-container" class="response-container">
    <!-- Response will be displayed here -->
</div>

<script>
// Global Google OAuth variables
let googleUser = null;
let googleAccessToken = null;

// Handle API key persistence and model selection
document.addEventListener('DOMContentLoaded', function() {
    // Google OAuth configuration
    const GOOGLE_CLIENT_ID = '927667106833-7od90q7nh5oage0shc3kka5s9vtg2loj.apps.googleusercontent.com'; // Replaced during build process

    // API key elements
    const openaiApiKeyInput = document.getElementById('openai_api_key');
    const groqApiKeyInput = document.getElementById('groq_api_key');
    const clearOpenaiButton = document.getElementById('clear_openai_api_key');
    const clearGroqButton = document.getElementById('clear_groq_api_key');
    const modelSelect = document.getElementById('model');
    const authBanner = document.getElementById('auth-banner');
    
    // Login elements
    const loginBtn = document.getElementById('login-btn');
    const loginText = document.getElementById('login-text');
    const submitBtn = document.getElementById('submit-btn');
    
    // Settings dialog elements
    const settingsBtn = document.getElementById('settings-btn');
    const settingsDialog = document.getElementById('settings-dialog');
    const closeSettingsBtn = document.getElementById('close-settings');
    
    // Model groups
    const openaiModels = document.getElementById('openai-models');
    const groqModels = document.getElementById('groq-models');
    
    // Function to update API key status
    function updateApiKeyStatus(elementId, message, color = '#6c757d') {
        const statusElement = document.getElementById(elementId);
        statusElement.textContent = message;
        statusElement.style.color = color;
    }
    
    // Auth banner helpers
    function setAuthBanner(kind, html) {
        if (!authBanner) return;
        authBanner.className = `auth-banner ${kind}`;
        authBanner.innerHTML = html;
        authBanner.style.display = 'block';
    }
    function clearAuthBanner() {
        if (!authBanner) return;
        authBanner.style.display = 'none';
        authBanner.className = 'auth-banner';
        authBanner.innerHTML = '';
    }
    
    // Google OAuth functions
    function initializeGoogleOAuth() {
        if (typeof google !== 'undefined' && google.accounts) {
            google.accounts.id.initialize({
                client_id: GOOGLE_CLIENT_ID,
                callback: handleGoogleSignIn
            });

            // Render a standard Google Sign-In button as a fallback/UI affordance
            try {
                const btnContainer = document.getElementById('google-button-container');
                if (btnContainer) {
                    google.accounts.id.renderButton(btnContainer, {
                        type: 'standard',
                        theme: 'filled_blue',
                        size: 'large',
                        text: 'signin_with',
                        shape: 'pill',
                    });
                }
            } catch (e) {
                console.warn('Google button render failed:', e);
            }

            // Attempt One Tap / FedCM prompt with diagnostics
            try {
                google.accounts.id.prompt(promptDiagnostics);
            } catch (e) {
                console.warn('Google prompt failed to start:', e);
            }
            
            // Try to restore previous session
            const savedToken = localStorage.getItem('google_access_token');
            const savedUser = localStorage.getItem('google_user');
            if (savedToken && savedUser) {
                if (isGoogleTokenValid(savedToken)) {
                    googleAccessToken = savedToken;
                    googleUser = JSON.parse(savedUser);
                    updateLoginUI(true);
                    updateSubmitButton();
                    updateModelAvailability();
                    console.log('Restored Google session');
                } else {
                    localStorage.removeItem('google_access_token');
                    localStorage.removeItem('google_user');
                    googleAccessToken = null;
                    googleUser = null;
                    updateLoginUI(false);
                    updateSubmitButton();
                    updateModelAvailability();
                    console.log('Cleared expired Google session; please sign in again');
                }
            }
        } else {
            console.error('Google Identity Services not loaded');
        }
    }
    
    function handleGoogleSignIn(response) {
        try {
            // Decode the JWT token to get user info
            const userInfo = parseJwt(response.credential);
            googleUser = {
                email: userInfo.email,
                name: userInfo.name,
                picture: userInfo.picture
            };
            googleAccessToken = response.credential;
            
            // Save to localStorage
            localStorage.setItem('google_access_token', googleAccessToken);
            localStorage.setItem('google_user', JSON.stringify(googleUser));
            
            updateLoginUI(true);
            updateSubmitButton();
            updateModelAvailability();
            console.log('Google sign-in successful:', googleUser.email);
        } catch (error) {
            console.error('Error handling Google sign-in:', error);
        }
    }
    
    function parseJwt(token) {
        const base64Url = token.split('.')[1];
        const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
        const jsonPayload = decodeURIComponent(window.atob(base64).split('').map(function(c) {
            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
        }).join(''));
        return JSON.parse(jsonPayload);
    }
    
    function updateLoginUI(isLoggedIn) {
        if (isLoggedIn && googleUser) {
            loginBtn.classList.add('logged-in');
            loginBtn.innerHTML = `
                <div class="profile-container">
                    <img src="${googleUser.picture}" alt="Profile" class="profile-picture">
                    <span class="logout-text">Logout</span>
                </div>
            `;
            setAuthBanner('ok', `
                <strong>Signed in as ${googleUser.email}</strong><br>
                <small>If your account is authorized, the server can use its own provider API keys when you leave the key fields empty.</small>
            `);
        } else {
            loginBtn.classList.remove('logged-in');
            loginBtn.innerHTML = '<span id="login-text">Sign in with Google</span>';
            setAuthBanner('warn', `
                <strong>Not signed in</strong> — Provide your own OpenAI/Groq API key in Settings to enable requests.
            `);
        }
    }
    
    // Validate Google ID token expiry (parse JWT payload; no signature verification)
    function isGoogleTokenValid(token) {
        try {
            if (!token) return false;
            const payload = parseJwt(token);
            if (!payload || !payload.exp) return false;
            const now = Math.floor(Date.now() / 1000);
            return payload.exp > now;
        } catch (e) {
            return false;
        }
    }
    // Expose globally for any external references
    window.isGoogleTokenValid = isGoogleTokenValid;

    // FedCM/GIS prompt diagnostics callback
    function promptDiagnostics(notification) {
        try {
            if (!notification) return;
            if (notification.isDisplayed && notification.isDisplayed()) {
                console.log('Google prompt displayed');
            }
            if (notification.isNotDisplayed && notification.isNotDisplayed()) {
                const reason = notification.getNotDisplayedReason && notification.getNotDisplayedReason();
                console.warn('Google prompt not displayed:', reason);
            }
            if (notification.isSkippedMoment && notification.isSkippedMoment()) {
                const reason = notification.getSkippedReason && notification.getSkippedReason();
                console.warn('Google prompt skipped:', reason);
            }
            if (notification.isDismissedMoment && notification.isDismissedMoment()) {
                const reason = notification.getDismissedReason && notification.getDismissedReason();
                console.warn('Google prompt dismissed:', reason);
            }
        } catch (e) {
            console.warn('Google prompt diagnostics error:', e);
        }
    }
    
    function hasLocalKeyForModel() {
        const sel = modelSelect.value || '';
        const openaiKey = (openaiApiKeyInput.value || '').trim();
        const groqKey = (groqApiKeyInput.value || '').trim();
        if (sel.startsWith('openai:')) return !!openaiKey;
        if (sel.startsWith('groq:')) return !!groqKey;
        return false;
    }
    function updateSubmitButton() {
        const signedIn = isGoogleTokenValid(googleAccessToken);
        const localKeyOk = hasLocalKeyForModel();
        const canSubmit = signedIn || localKeyOk;
        
        // Debug logging
        console.log('updateSubmitButton:', {
            googleAccessToken: googleAccessToken ? (signedIn ? 'present-valid' : 'present-expired') : 'null',
            googleUser: googleUser ? googleUser.email : 'null',
            signedIn: signedIn,
            localKeyOk: localKeyOk,
            canSubmit: canSubmit,
            savedToken: localStorage.getItem('google_access_token') ? 'present' : 'null'
        });
        
        submitBtn.disabled = !canSubmit;
        submitBtn.textContent = canSubmit ? 'Send Request' : 'Sign in or add an API key';
    }
    
    function handleLogin() {
        if (googleUser) {
            // User is logged in, so logout
            logout();
        } else {
            // User is not logged in, so show sign-in prompt
            if (typeof google !== 'undefined' && google.accounts) {
                try {
                    google.accounts.id.prompt(promptDiagnostics);
                } catch (e) {
                    console.warn('Google prompt error:', e);
                }
                // After prompt, state may change; attempt to refresh UI shortly
                setTimeout(() => { updateSubmitButton(); updateModelAvailability(); }, 1500);
            } else {
                console.error('Google Identity Services not available');
            }
        }
    }
    
    function logout() {
        googleUser = null;
        googleAccessToken = null;
        localStorage.removeItem('google_access_token');
        localStorage.removeItem('google_user');
        updateLoginUI(false);
        updateSubmitButton();
        updateModelAvailability();
        console.log('Logged out');
    }
    
    // Function to update model availability based on API keys
    function updateModelAvailability() {
        console.log('updateModelAvailability called');
        const hasOpenaiKey = !!(openaiApiKeyInput.value && openaiApiKeyInput.value.trim());
        const hasGroqKey = !!(groqApiKeyInput.value && groqApiKeyInput.value.trim());
    const signedIn = isGoogleTokenValid(googleAccessToken);
        
        console.log('hasOpenaiKey:', hasOpenaiKey, 'hasGroqKey:', hasGroqKey, 'signedIn:', signedIn);
        
        // Enable/disable individual options based on available API keys, but keep them visible
        const allOptions = modelSelect.querySelectorAll('option');
        let hasAvailableOptions = false;
        let firstAvailableOption = null;
        
        allOptions.forEach(option => {
            if (!option.value) {
                // Skip empty options
                return;
            }
            
            let shouldEnable = false;
            if (option.value.startsWith('openai:')) {
                shouldEnable = hasOpenaiKey || signedIn;
                // Add visual indicator for disabled options
                option.textContent = option.textContent.replace(' (requires API key)', '');
                if (!shouldEnable) {
                    option.textContent += ' (requires API key)';
                }
            } else if (option.value.startsWith('groq:')) {
                shouldEnable = hasGroqKey || signedIn;
                // Add visual indicator for disabled options
                option.textContent = option.textContent.replace(' (requires API key)', '');
                if (!shouldEnable) {
                    option.textContent += ' (requires API key)';
                }
            }
            
            option.disabled = !shouldEnable;
            // Keep all options visible, just disable unavailable ones
            option.style.display = '';
            
            if (shouldEnable) {
                hasAvailableOptions = true;
                if (!firstAvailableOption) {
                    firstAvailableOption = option;
                }
            }
        });
        
        // If no keys and not signed in, disable the entire selector
        if (!hasAvailableOptions && !signedIn) {
            modelSelect.disabled = true;
            console.log('No API keys available, disabling model select');
        } else {
            modelSelect.disabled = false;
            console.log('API keys available, enabling model select');
            
            // Check if current selection is still valid
            const currentOption = modelSelect.querySelector(`option[value="${modelSelect.value}"]`);
            if (!currentOption || currentOption.disabled) {
                // Set default model based on available API keys
                let defaultModel = null;
                
                // Priority 1: Groq llama instant if Groq key is available (and no OpenAI key)
                if (hasGroqKey) {
                    defaultModel = 'groq:llama-3.1-8b-instant';
                // Priority 2: OpenAI gpt-5-nano if OpenAI key is available
                } else if (hasOpenaiKey) {
                    defaultModel = 'openai:gpt-5-nano';
                }
                 
                
                // Apply default model if available, otherwise use first available option
                if (defaultModel && modelSelect.querySelector(`option[value="${defaultModel}"]`) && 
                    !modelSelect.querySelector(`option[value="${defaultModel}"]`).disabled) {
                    modelSelect.value = defaultModel;
                    console.log('Selected default model:', defaultModel);
                } else if (firstAvailableOption) {
                    modelSelect.value = firstAvailableOption.value;
                    console.log('Selected first available model:', firstAvailableOption.value);
                }
            }
        }
    }
    
    // Load saved API keys on page load
    const savedOpenaiApiKey = localStorage.getItem('openai_api_key');
    if (savedOpenaiApiKey) {
        openaiApiKeyInput.value = savedOpenaiApiKey;
        updateApiKeyStatus('openai_api_key_status', 'Loaded from local storage', '#28a745');
        clearOpenaiButton.style.display = 'block';
    }
    
    const savedGroqApiKey = localStorage.getItem('groq_api_key');
    if (savedGroqApiKey) {
        groqApiKeyInput.value = savedGroqApiKey;
        updateApiKeyStatus('groq_api_key_status', 'Loaded from local storage', '#28a745');
        clearGroqButton.style.display = 'block';
    }
    
    // Set initial default model based on available API keys
    function setInitialDefaultModel() {
        const hasOpenaiKey = savedOpenaiApiKey && savedOpenaiApiKey.trim();
        const hasGroqKey = savedGroqApiKey && savedGroqApiKey.trim();
        
        // Only set default if no model is currently selected
        if (!modelSelect.value || modelSelect.value === '') {
            if (hasGroqKey) {
                modelSelect.value = 'groq:llama-3.1-8b-instant';
                console.log('Set initial default model to llama-3.1-8b-instant (Groq key available - prioritized for speed)');
            } else if (hasOpenaiKey) {
                modelSelect.value = 'openai:gpt-4o-mini';
                console.log('Set initial default model to gpt-4o-mini (OpenAI key available)');
            }
        }
    }
    
    // Update model availability on initial load
    updateModelAvailability();
    updateSubmitButton();
    
    // Set initial default model
    setInitialDefaultModel();
    
    // Also call it after a small delay to ensure localStorage values are set
    setTimeout(() => { updateModelAvailability(); updateSubmitButton(); }, 100);
    
    // Save OpenAI API key when it changes
    openaiApiKeyInput.addEventListener('input', function() {
        const apiKey = this.value.trim();
        if (apiKey && apiKey.trim()) {
            localStorage.setItem('openai_api_key', apiKey);
            updateApiKeyStatus('openai_api_key_status', 'Saved to local storage', '#28a745');
            clearOpenaiButton.style.display = 'block';
        } else if (!apiKey) {
            updateApiKeyStatus('openai_api_key_status', '');
            clearOpenaiButton.style.display = 'none';
        }
        updateModelAvailability();
    });
    
    // Save Groq API key when it changes
    groqApiKeyInput.addEventListener('input', function() {
        const apiKey = this.value.trim();
        if (apiKey && apiKey.trim()) {
            localStorage.setItem('groq_api_key', apiKey);
            updateApiKeyStatus('groq_api_key_status', 'Saved to local storage', '#28a745');
            clearGroqButton.style.display = 'block';
        } else if (!apiKey) {
            updateApiKeyStatus('groq_api_key_status', '');
            clearGroqButton.style.display = 'none';
        }
        updateModelAvailability();
    });
    
    // Handle clear OpenAI button
    clearOpenaiButton.addEventListener('click', function() {
        localStorage.removeItem('openai_api_key');
        openaiApiKeyInput.value = '';
        updateApiKeyStatus('openai_api_key_status', 'Cleared from local storage', '#dc3545');
        clearOpenaiButton.style.display = 'none';
        updateModelAvailability();
        setTimeout(() => {
            updateApiKeyStatus('openai_api_key_status', '');
        }, 3000);
    });
    
    // Handle clear Groq button
    clearGroqButton.addEventListener('click', function() {
        localStorage.removeItem('groq_api_key');
        groqApiKeyInput.value = '';
        updateApiKeyStatus('groq_api_key_status', 'Cleared from local storage', '#dc3545');
        clearGroqButton.style.display = 'none';
        updateModelAvailability();
        setTimeout(() => {
            updateApiKeyStatus('groq_api_key_status', '');
        }, 3000);
    });
    
    // Handle OpenAI help button
    document.getElementById('openai_help_button').addEventListener('click', function() {
        window.open('https://platform.openai.com/api-keys', '_blank');
    });
    
    // Handle Groq help button
    document.getElementById('groq_help_button').addEventListener('click', function() {
        window.open('https://console.groq.com/keys', '_blank');
    });
    
    // Settings dialog functionality
    function openSettings() {
        settingsDialog.style.display = 'block';
    }
    
    function closeSettings() {
        settingsDialog.style.display = 'none';
    }
    
    // Check if API keys are available, open settings if not
    function checkInitialSettings() {
        const hasOpenaiKey = localStorage.getItem('openai_api_key');
        const hasGroqKey = localStorage.getItem('groq_api_key');
        const signedIn = !!localStorage.getItem('google_access_token');
        
        // Open settings dialog by default if no API keys are set and not signed in
        if (!hasOpenaiKey && !hasGroqKey && !signedIn) {
            openSettings();
        }
    }
    
    // Settings button event listeners
    settingsBtn.addEventListener('click', openSettings);
    closeSettingsBtn.addEventListener('click', closeSettings);
    
    // Login button event listener
    loginBtn.addEventListener('click', handleLogin);
    
    // Initialize Google OAuth when the page loads
    setTimeout(initializeGoogleOAuth, 1000); // Delay to ensure Google script is loaded
    
    // Close dialog when clicking outside
    settingsDialog.addEventListener('click', function(e) {
        if (e.target === settingsDialog) {
            closeSettings();
        }
    });
    
    // Close dialog with escape key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && settingsDialog.style.display === 'block') {
            closeSettings();
        }
    });
    
    // Check initial settings after everything is loaded
    checkInitialSettings();

    // Keep submit button state in sync with inputs
    modelSelect.addEventListener('change', () => { updateModelAvailability(); updateSubmitButton(); });
    openaiApiKeyInput.addEventListener('input', () => { updateModelAvailability(); updateSubmitButton(); });
    groqApiKeyInput.addEventListener('input', () => { updateModelAvailability(); updateSubmitButton(); });

    // When Tab is pressed inside the textarea, move focus to the Submit button
    const promptTextarea = document.getElementById('prompt');
    if (promptTextarea) {
        promptTextarea.addEventListener('keydown', function(e) {
            if (e.key === 'Tab' && !e.shiftKey) {
                e.preventDefault();
                // Focus the Send Request button
                if (submitBtn) {
                    submitBtn.focus();
                }
            }
        });
    }
    // Ensure button state is accurate after wiring listeners
    updateSubmitButton();
});

document.getElementById('llm-form').addEventListener('submit', async function(e) {
    e.preventDefault();
    
    const submitBtn = document.getElementById('submit-btn');
    const responseContainer = document.getElementById('response-container');
    
    // Disable submit button and show loading state
    submitBtn.disabled = true;
    submitBtn.textContent = 'Sending...';
    
    // Show loading message
    responseContainer.className = 'response-container loading';
    responseContainer.style.display = 'block';
    responseContainer.textContent = 'Sending request...';
    
    // Get the selected model to determine which API key to use
    const selectedModel = document.getElementById('model').value;
    const isGroqModel = selectedModel.startsWith('groq:');
    const isOpenaiModel = selectedModel.startsWith('openai:');
    
    // Get the appropriate API key
    let apiKey;
    if (isGroqModel) {
        apiKey = document.getElementById('groq_api_key').value;
    } else if (isOpenaiModel) {
        apiKey = document.getElementById('openai_api_key').value;
    }
    
    // Validate that we have either a local API key or a Google login (server env keys may apply)
    const hasLocalKey = apiKey && apiKey.trim();
    const isSignedIn = (window.isGoogleTokenValid ? window.isGoogleTokenValid(googleAccessToken) : false);
    
    // Debug logging
    console.log('Form submission validation:', {
        apiKey: apiKey ? 'present' : 'null',
        hasLocalKey: hasLocalKey,
        googleAccessToken: googleAccessToken ? 'present' : 'null',
        isSignedIn: isSignedIn,
        googleUser: googleUser ? googleUser.email : 'null'
    });
    
    if (!hasLocalKey && !isSignedIn) {
        responseContainer.className = 'response-container response-error';
        responseContainer.textContent = 'Error: Please sign in with Google or provide an API key in Settings to proceed.';
        // Proactively open Google sign-in prompt if available
        try { if (typeof google !== 'undefined' && google.accounts) google.accounts.id.prompt(); } catch (e) { /* noop */ }
        // Nudge focus to Login button
        try { const lb = document.getElementById('login-btn'); if (lb) lb.focus(); } catch (e) { /* noop */ }
        submitBtn.disabled = false;
        submitBtn.textContent = 'Send Request';
        return;
    }

    // Collect form data
    const searchMode = document.querySelector('input[name="search_mode"]:checked').value;
    const formData = {
        // Only include apiKey if user provided one; otherwise server may use env keys for authorized accounts
        ...(hasLocalKey ? { apiKey: apiKey } : {}),
        model: selectedModel,
        query: document.getElementById('prompt').value,
        accessSecret: document.getElementById('access_secret').value,  // Changed from access_secret to accessSecret
        searchMode: searchMode,  // Changed from search_mode to searchMode
        ...(isSignedIn ? { google_token: googleAccessToken } : {})
    };

    // Set a reasonable default timeout (90 seconds)
    const timeoutMs = 90000;

    // Create an AbortController for timeout handling
    const controller = new AbortController();
    const timeoutId = setTimeout(() => {
        controller.abort();
    }, timeoutMs);
    
    try {
    console.log('Sending request to:', 'https://nrw7pperjjdswbmqgmigbwsbyi0rwdqf.lambda-url.us-east-1.on.aws/');
        console.log('Request data:', formData);
        
        // Update loading message
        responseContainer.textContent = 'Sending request...';
        
        const response = await fetch('https://nrw7pperjjdswbmqgmigbwsbyi0rwdqf.lambda-url.us-east-1.on.aws/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'text/event-stream'  // Request streaming response
            },
            body: JSON.stringify(formData),
            mode: 'cors',
            credentials: 'omit',
            signal: controller.signal // Add timeout signal
        });
        
        // Clear the timeout since we got a response
        clearTimeout(timeoutId);
        
        console.log('Response status:', response.status);
        console.log('Response headers:', response.headers);
        
        // Check if response is streaming
        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('text/event-stream')) {
            console.log('Handling streaming response');
            await handleStreamingResponse(response, responseContainer, controller);
            return; // Exit early for streaming
        }
        
        // Handle regular JSON response (existing logic)
        const responseData = await response.text();
        console.log('Response data:', responseData);
        
        if (response.ok) {
            // Success response - parse JSON and display enhanced response
            try {
                const jsonData = JSON.parse(responseData);
                // Use 'response' field from Lambda function, fallback to 'answer'
                const answer = jsonData.response || jsonData.answer || 'No response found';
                
                responseContainer.className = 'response-container response-success';
                responseContainer.style.fontFamily = 'inherit';
                
                // Create enhanced response with answer, search info, and results
                let responseHTML = `<div class="answer-content">${answer.replace(/\n/g, '<br>')}</div>`;
                
                // Add search summary if available
                if (jsonData.searches && jsonData.searches.length > 0) {
                    const totalResults = jsonData.searchResults ? jsonData.searchResults.length : 0;
                    const totalSearches = jsonData.searches.length;
                    
                    // Count iterations
                    const iterations = [...new Set(jsonData.searches.map(s => s.iteration))];
                    
                    responseHTML += `<div class="search-summary">
                        <h3>Search Summary</h3>
                        <p><strong>Total:</strong> ${totalResults} results from ${totalSearches} searches across ${iterations.length} iterations</p>
                    </div>`;
                    
                    // Group searches by iteration
                    const searchesByIteration = {};
                    jsonData.searches.forEach(search => {
                        if (!searchesByIteration[search.iteration]) {
                            searchesByIteration[search.iteration] = [];
                        }
                        searchesByIteration[search.iteration].push(search);
                    });
                    
                    // Display searches by iteration in expandable sections
                    responseHTML += '<div class="search-iterations">';
                    Object.keys(searchesByIteration).sort().forEach(iteration => {
                        const searches = searchesByIteration[iteration];
                        const iterationResults = searches.reduce((sum, s) => sum + s.resultsCount, 0);
                        
                        responseHTML += `<details class="iteration-section">
                            <summary><strong>Iteration ${iteration}</strong> - ${searches.length} searches, ${iterationResults} results</summary>
                            <ul class="search-list">`;
                        searches.forEach(search => {
                            responseHTML += `<li><strong>${search.query}</strong> (${search.resultsCount} results)</li>`;
                        });
                        responseHTML += '</ul></details>';
                    });
                    responseHTML += '</div>';
                }
                
                // Add search results if available
                if (jsonData.searchResults && jsonData.searchResults.length > 0) {
                    responseHTML += `<details class="search-results-section">
                        <summary><strong>Search Results</strong> (${jsonData.searchResults.length} total)</summary>
                        <div class="search-results">`;
                    
                    jsonData.searchResults.slice(0, 10).forEach((result, index) => {
                        responseHTML += `<div class="result-item">
                            <h4><a href="${result.url}" target="_blank">${result.title}</a></h4>
                            <p class="result-description">${result.description || 'No description available'}</p>
                            <p class="result-url"><small>${result.url}</small></p>
                        </div>`;
                    });
                    
                    if (jsonData.searchResults.length > 10) {
                        responseHTML += `<p><em>... and ${jsonData.searchResults.length - 10} more results</em></p>`;
                    }
                    
                    responseHTML += '</div></details>';
                }
                
                // Add debug info for full response
                responseHTML += `<details class="debug-info">
                    <summary>Full Response JSON</summary>
                    <pre>${JSON.stringify(jsonData, null, 2)}</pre>
                </details>`;
                
                responseContainer.innerHTML = responseHTML;
            } catch (parseError) {
                // If JSON parsing fails, show the raw response
                responseContainer.className = 'response-container response-success';
                responseContainer.textContent = `Success (${response.status}):\n\n${responseData}`;
            }
        } else {
            // Error response from server
            responseContainer.className = 'response-container response-error';
            responseContainer.style.fontFamily = 'monospace'; // Keep monospace for error details
            responseContainer.textContent = `Error (${response.status}):\n\n${responseData}`;
        }
    } catch (error) {
        // Clear the timeout in case of other errors
        clearTimeout(timeoutId);
        
        // Network or other errors
        console.error('Request error:', error);
        
        responseContainer.className = 'response-container response-error';
        
        if (error.name === 'AbortError') {
            // Request was aborted due to timeout
            responseContainer.textContent = `Request Timeout Error:\n\nThe request timed out after 90 seconds. The Lambda function may be taking longer than expected to process your request.\n\nYou can try:\n- Simplifying your query\n- Checking if the Lambda function is running properly\n- Trying again in a moment`;
        } else {
            // Other network or fetch errors
            responseContainer.textContent = `Network Error:\n\n${error.message}\n\nCheck browser console for more details.`;
        }
    } finally {
        // Re-enable submit button
        submitBtn.disabled = false;
        submitBtn.textContent = 'Send Request';
    }
});

/**
 * Handle streaming Server-Sent Events response
 */
async function handleStreamingResponse(response, responseContainer, controller) {
    console.log('Starting streaming response handler');
    
    // Clear and prepare response container for streaming
    responseContainer.className = 'response-container';
    responseContainer.innerHTML = `
        <div id="streaming-response" style="margin-bottom: 16px;">
            <div style="padding: 15px; background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; border-radius: 8px; margin-bottom: 10px;">
                <h3 style="margin: 0; display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 1.2em;">�</span> Final Response
                </h3>
            </div>
            <div id="final-answer" style="padding: 16px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #28a745; line-height: 1.6; color:#212529;">
                <em>Working on it… you'll see the final answer here as soon as it's ready.</em>
            </div>
        </div>
        <div id="streaming-metadata" style="margin-top: 8px; padding: 12px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e9ecef;">
            <h4 style="margin: 0 0 10px 0; color: #495057; display: flex; align-items: center; gap: 8px;">
                <span>�</span> Search Summary
            </h4>
            <div id="metadata-content"></div>
            <ul id="search-summary-list" style="margin: 10px 0 0 0; padding-left: 20px;"></ul>
        </div>
        <div style="margin-top: 16px; padding: 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
            <h3 style="margin: 0 0 8px 0; display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 1.2em;">�</span> Real-time Search Progress
            </h3>
            <div style="display:flex; align-items:center; gap:10px; justify-content:space-between; flex-wrap:wrap;">
                <div id="streaming-status" style="opacity: 0.95;">Connected! Waiting for data...</div>
                <button id="stop-button" type="button" style="background:#dc3545; color:#fff; border:none; padding:6px 10px; border-radius:6px; cursor:pointer; font-weight:600;">Stop</button>
            </div>
        </div>
        <div id="active-searches" style="margin:10px 0; padding:10px; background:#f8f9fa; border:1px solid #e9ecef; border-radius:8px; display:none;"></div>
        <div id="streaming-steps" style="margin: 10px 0 16px 0;"></div>
        <div id="full-results-tree"></div>
    `;
    
    const statusElement = document.getElementById('streaming-status');
    const stepsElement = document.getElementById('streaming-steps');
    const responseElement = document.getElementById('streaming-response');
    const answerElement = document.getElementById('final-answer');
    const metadataElement = document.getElementById('streaming-metadata');
    const metadataContent = document.getElementById('metadata-content');
    const searchSummaryList = document.getElementById('search-summary-list');
    const fullResultsTree = document.getElementById('full-results-tree');
    const stopButton = document.getElementById('stop-button');
    const activeSearchesEl = document.getElementById('active-searches');
    
    // Maintain structured state for full results tree
    const resultsState = { byIteration: {} };
    // Map of per-search digests: key `${iteration}|${term}` => { summary, links }
    const digestMap = new Map();
    // Map of per-search metadata: key `${iteration}|${term}` => { subQuestion, keywords }
    const metaMap = new Map();
    // Track active searches and countdowns
    const activeTimers = new Map(); // key -> { start, maxMs, intervalId, barInner, label }
    const SEARCH_MAX_MS = 15000; // UI estimate per-search timeout (ms)

    function ensureActiveHeaderVisible() {
        if (activeTimers.size > 0) {
            activeSearchesEl.style.display = 'block';
            if (!activeSearchesEl.__header) {
                const h = document.createElement('div');
                h.style.cssText = 'font-weight:600; color:#495057; margin-bottom:8px;';
                h.textContent = 'Active searches';
                activeSearchesEl.appendChild(h);
                activeSearchesEl.__header = h;
            }
        } else {
            activeSearchesEl.style.display = 'none';
        }
    }

    function startSearchTimer(iteration, term, index, total) {
        const key = `${iteration}|${term}`;
        if (activeTimers.has(key)) return;
        const wrap = document.createElement('div');
        wrap.style.cssText = 'margin:6px 0;';
        const label = document.createElement('div');
        label.style.cssText = 'font-size:0.9em; color:#495057; margin-bottom:4px; display:flex; justify-content:space-between; gap:8px;';
        label.innerHTML = `<span>(${index}/${total}) "${term}"</span><span class="time">${Math.round(SEARCH_MAX_MS/1000)}s</span>`;
        const bar = document.createElement('div');
        bar.style.cssText = 'height:10px; background:#e9ecef; border-radius:6px; overflow:hidden;';
        const inner = document.createElement('div');
        inner.style.cssText = 'height:100%; width:0%; background:linear-gradient(90deg, #ffda79, #f0932b); transition:width 0.2s linear;';
        bar.appendChild(inner);
        wrap.appendChild(label);
        wrap.appendChild(bar);
        activeSearchesEl.appendChild(wrap);
        ensureActiveHeaderVisible();
        const start = Date.now();
        const intervalId = setInterval(() => {
            const elapsed = Date.now() - start;
            const pct = Math.min(100, (elapsed/SEARCH_MAX_MS)*100);
            inner.style.width = pct + '%';
            const remain = Math.max(0, Math.ceil((SEARCH_MAX_MS - elapsed)/1000));
            const timeEl = label.querySelector('.time');
            if (timeEl) timeEl.textContent = `${remain}s`;
            if (elapsed >= SEARCH_MAX_MS) {
                // Mark as timed out visually but keep it until we get results or completion
                inner.style.background = 'linear-gradient(90deg, #ff6b6b, #c44569)';
                clearInterval(intervalId);
            }
        }, 200);
        activeTimers.set(key, { start, maxMs: SEARCH_MAX_MS, intervalId, barInner: inner, label, wrap });
    }

    function stopSearchTimer(iteration, term, status = 'done') {
        const key = `${iteration}|${term}`;
        const t = activeTimers.get(key);
        if (!t) return;
        if (t.intervalId) clearInterval(t.intervalId);
        // Update color based on status
        if (status === 'done') {
            t.barInner.style.width = '100%';
            t.barInner.style.background = 'linear-gradient(90deg, #2ecc71, #27ae60)';
        } else if (status === 'stopped') {
            t.barInner.style.background = 'linear-gradient(90deg, #6c757d, #495057)';
        } else if (status === 'error') {
            t.barInner.style.background = 'linear-gradient(90deg, #ff6b6b, #c44569)';
        }
        // Remove after short delay to keep feedback visible
        setTimeout(() => {
            if (t.wrap && t.wrap.parentElement) t.wrap.parentElement.removeChild(t.wrap);
            activeTimers.delete(key);
            ensureActiveHeaderVisible();
        }, 800);
    }

    function stopAllTimers(status = 'stopped') {
        for (const key of Array.from(activeTimers.keys())) {
            const [iter, term] = key.split('|');
            stopSearchTimer(iter, term, status);
        }
    }

    // Wire Stop button
    if (stopButton) {
        stopButton.addEventListener('click', () => {
            try { controller && controller.abort(); } catch {}
            stopButton.disabled = true;
            stopButton.textContent = 'Stopping...';
            statusElement.textContent = '⏹️ Stopping — no further requests will be made.';
            stopAllTimers('stopped');
        });
    }
    
    function renderResultsSection(title, results, digest, meta) {
        const details = document.createElement('details');
        details.className = 'search-results-section';
        details.open = false;
        const summary = document.createElement('summary');
        summary.innerHTML = `<strong>${title}</strong> (${results.length} total)`;
        details.appendChild(summary);
        // Sub-question heading and keywords badges
        if (meta && (meta.subQuestion || (Array.isArray(meta.keywords) && meta.keywords.length))) {
            const metaBox = document.createElement('div');
            metaBox.style.cssText = 'margin:10px 12px; padding:10px; background:#f8f9fa; border:1px solid #e9ecef; border-radius:6px;';
            if (meta.subQuestion) {
                const h = document.createElement('div');
                h.style.cssText = 'font-weight:600; color:#343a40; margin-bottom:6px;';
                h.textContent = `Sub-question: ${meta.subQuestion}`;
                metaBox.appendChild(h);
            }
            if (Array.isArray(meta.keywords) && meta.keywords.length) {
                const kwWrap = document.createElement('div');
                kwWrap.style.cssText = 'display:flex; flex-wrap:wrap; gap:6px;';
                meta.keywords.forEach(k => {
                    const badge = document.createElement('span');
                    badge.style.cssText = 'background:#e9f5ff; color:#0b6aa2; border:1px solid #b6e0fe; padding:2px 8px; border-radius:12px; font-size:0.85em;';
                    badge.textContent = k;
                    kwWrap.appendChild(badge);
                });
                metaBox.appendChild(kwWrap);
            }
            details.appendChild(metaBox);
        }
        // If we have a per-search digest summary, render it prominently at the top of this section
        if (digest && (digest.summary || (Array.isArray(digest.links) && digest.links.length))) {
            const digestBox = document.createElement('div');
            digestBox.style.cssText = 'margin:10px 12px; padding:10px; background:#fff; border-left:4px solid #007bff; border:1px solid #e9ecef; border-radius:6px;';
            if (digest.summary) {
                const p = document.createElement('div');
                p.style.cssText = 'color:#212529; line-height:1.5;';
                p.textContent = digest.summary;
                digestBox.appendChild(p);
            }
            if (Array.isArray(digest.links) && digest.links.length) {
                const ul = document.createElement('ul');
                ul.style.cssText = 'margin-top:6px;';
                digest.links.forEach(l => {
                    const li = document.createElement('li');
                    li.innerHTML = `<a href="${l.url}" target="_blank" rel="noopener noreferrer">${l.title || l.url}</a>${l.snippet ? ` — <small>${l.snippet}</small>` : ''}`;
                    ul.appendChild(li);
                });
                digestBox.appendChild(ul);
            }
            details.appendChild(digestBox);
        }
        const wrap = document.createElement('div');
        wrap.className = 'search-results';
        results.slice(0, 20).forEach(r => {
            const item = document.createElement('div');
            item.className = 'result-item';
            item.innerHTML = `
                <h4><a href="${r.url}" target="_blank" rel="noopener noreferrer">${r.title || r.url}</a></h4>
                <p class="result-description">${r.description || 'No description available'}</p>
                <p class="result-url"><small>${r.url}</small></p>
            `;
            wrap.appendChild(item);
        });
        if (results.length > 20) {
            const more = document.createElement('p');
            more.innerHTML = `<em>... and ${results.length - 20} more results</em>`;
            wrap.appendChild(more);
        }
        details.appendChild(wrap);
        return details;
    }
    
    function updateLiveSummary(searches, total) {
        metadataElement.style.display = 'block';
        const iters = [...new Set((searches || []).map(s => s.iteration))];
        metadataContent.innerHTML = `
            <div><strong>Total results so far:</strong> ${total || 0}</div>
            <div><strong>Searches performed:</strong> ${(searches || []).length} across ${iters.length} iteration(s)</div>
        `;
        // Update list of searches with counts; include placeholder for per-search LLM summaries when available
        searchSummaryList.innerHTML = '';
        (searches || []).forEach(s => {
            const li = document.createElement('li');
            li.innerHTML = `<strong>Iteration ${s.iteration}</strong>: \"${s.query}\" — ${s.resultsCount} result(s)`;
            // Sub-question heading inline
            if (s.subQuestion) {
                const sub = document.createElement('div');
                sub.style.cssText = 'margin-top:2px; color:#495057; font-size:0.9em;';
                sub.textContent = `Sub-question: ${s.subQuestion}`;
                li.appendChild(sub);
            }
            if (Array.isArray(s.keywords) && s.keywords.length) {
                const kw = document.createElement('div');
                kw.style.cssText = 'margin-top:4px; display:flex; flex-wrap:wrap; gap:6px;';
                s.keywords.forEach(k => {
                    const badge = document.createElement('span');
                    badge.style.cssText = 'background:#eef7ee; color:#226633; border:1px solid #cde7ce; padding:2px 8px; border-radius:12px; font-size:0.85em;';
                    badge.textContent = k;
                    kw.appendChild(badge);
                });
                li.appendChild(kw);
            }
            // Show per-search digest if available (from digestMap or inline summary)
            const key = `${s.iteration}|${s.query}`;
            const digest = digestMap.get(key) || (s.summary ? { summary: s.summary, links: s.links || [] } : null);
            if (digest && digest.summary) {
                const p = document.createElement('div');
                p.style.cssText = 'margin-top:4px;color:#495057;';
                p.textContent = digest.summary;
                li.appendChild(p);
                if (Array.isArray(digest.links) && digest.links.length) {
                    const ul = document.createElement('ul');
                    ul.style.marginTop = '4px';
                    digest.links.forEach(l => {
                        const li2 = document.createElement('li');
                        li2.innerHTML = `<a href="${l.url}" target="_blank" rel="noopener noreferrer">${l.title || l.url}</a>${l.snippet ? ` — <small>${l.snippet}</small>` : ''}`;
                        ul.appendChild(li2);
                    });
                    li.appendChild(ul);
                }
            }
            searchSummaryList.appendChild(li);
        });
    }

    function updateFullResultsTree() {
        // Build a closed-by-default tree grouped by iteration -> query -> results
        fullResultsTree.innerHTML = '';
        const top = document.createElement('details');
        top.open = false;
        top.className = 'search-results-section';
        const topSummary = document.createElement('summary');
        // Count total results
        let total = 0;
        Object.values(resultsState.byIteration).forEach(iter => {
            Object.values(iter).forEach(arr => total += arr.length);
        });
        topSummary.innerHTML = `<strong>Full search results</strong> (${total} total)`;
        top.appendChild(topSummary);

        const container = document.createElement('div');
        container.style.marginTop = '8px';

        Object.keys(resultsState.byIteration).sort((a,b)=>Number(a)-Number(b)).forEach(iter => {
            const iterDetails = document.createElement('details');
            iterDetails.open = false;
            const iterSummary = document.createElement('summary');
            // Count iteration total
            let iterTotal = 0;
            Object.values(resultsState.byIteration[iter]).forEach(arr => iterTotal += arr.length);
            iterSummary.innerHTML = `<strong>Iteration ${iter}</strong> (${iterTotal} results)`;
            iterDetails.appendChild(iterSummary);

            Object.keys(resultsState.byIteration[iter]).forEach(term => {
                const termResults = resultsState.byIteration[iter][term];
                // Pull digest and metadata for this iteration/term if available
                const key = `${iter}|${term}`;
                const digest = digestMap.get(key) || null;
                const meta = metaMap.get(key) || null;
                const termDetails = renderResultsSection(`\"${term}\"`, termResults, digest, meta);
                iterDetails.appendChild(termDetails);
            });

            container.appendChild(iterDetails);
        });

        top.appendChild(container);
        fullResultsTree.appendChild(top);
    }
    
    try {
        // Handle streaming response
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        
        while (true) {
            const { done, value } = await reader.read();
            
            if (done) {
                console.log('Stream ended');
                statusElement.textContent = 'Stream completed';
                break;
            }
            
            // Decode and process chunk
            buffer += decoder.decode(value, { stream: true });
            
            // Process complete events (separated by double newlines)
            const events = buffer.split('\n\n');
            buffer = events.pop(); // Keep incomplete event in buffer
            
            for (const event of events) {
                if (!event.trim()) continue;
                
                try {
                    // Parse Server-Sent Events format
                    const lines = event.trim().split('\n');
                    let eventType = 'message';
                    let data = '';
                    
                    for (const line of lines) {
                        if (line.startsWith('event: ')) {
                            eventType = line.substring(7);
                        } else if (line.startsWith('data: ')) {
                            data = line.substring(6);
                        }
                    }
                    
                    if (!data) continue;
                    
                    const eventData = JSON.parse(data);
                    console.log('Received event:', eventType, eventData);
                    
                    // Handle different event types
                    switch (eventType) {
                        case 'search_digest':
                            {
                                const { term, iteration, summary, links, subQuestion, keywords } = eventData;
                                const key = `${iteration}|${term}`;
                                digestMap.set(key, { summary, links: Array.isArray(links) ? links : [] });
                                if (subQuestion || (Array.isArray(keywords) && keywords.length)) {
                                    metaMap.set(key, { subQuestion: subQuestion || null, keywords: Array.isArray(keywords) ? keywords : [] });
                                }
                                // Trigger a refresh of the Search Summary list (uses last known searches from metadata or previous event)
                                // We can’t access a persistent list of searches here, so rely on latest rendered summary; a full refresh will come with next search_results
                                // Optional: we could store lastSearches in closure when search_results arrives
                                if (typeof window.__lastSearches !== 'undefined') {
                                    updateLiveSummary(window.__lastSearches, undefined);
                                }
                                // Also refresh the full results tree so digest appears in the expandable section
                                updateFullResultsTree();
                            }
                            break;
                        case 'log':
                            statusElement.textContent = eventData.message || 'Processing...';
                            break;
                            
                        case 'init':
                            statusElement.textContent = `🔍 Starting search for: "${eventData.query}"`;
                            if (eventData.allowEnvFallback) {
                                const note = document.createElement('div');
                                note.style.cssText = 'margin-top:6px;color:#155724;font-size:0.9em;';
                                note.textContent = 'Note: Using server-managed API keys (authorized user).';
                                statusElement.parentElement.appendChild(note);
                            }
                            break;
                            
                        case 'decision':
                            {
                                const needsSearch = (eventData.decision && (eventData.decision.needsSearch ?? eventData.decision.requiresSearch)) || false;
                                const searchStrategy = needsSearch ? 'Multi-search required' : 'Direct response';
                                stepsElement.innerHTML += `
                                    <div style="margin: 10px 0; padding: 15px; background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                                        <div style="font-weight: bold; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;\">
                                            <span>🎯</span> Search Strategy: ${searchStrategy}
                                        </div>
                                        ${eventData.decision && eventData.decision.searchTerms ? `<div style=\"opacity: 0.9;\"><strong>Search Terms:</strong> ${eventData.decision.searchTerms.join(', ')}</div>` : ''}
                                    </div>
                                `;
                            }
                            break;
                            
                        case 'step':
                            if (eventData.type === 'search_iteration') {
                                stepsElement.innerHTML += `
                                    <div style="margin: 10px 0; padding: 15px; background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); color: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                                        <div style="font-weight: bold; display: flex; align-items: center; gap: 8px;">
                                            <span>🔄</span> Iteration ${eventData.iteration}: ${eventData.message}
                                        </div>
                                    </div>
                                `;
                            } else {
                                statusElement.textContent = eventData.message;
                            }
                            break;
                            
                        case 'search':
                            statusElement.textContent = `🔍 Searching (${eventData.searchIndex}/${eventData.totalSearches}): "${eventData.term}"`;
                            // Start a countdown bar for this active search
                            startSearchTimer(eventData.iteration, eventData.term, eventData.searchIndex, eventData.totalSearches);
                            break;
                            
                        case 'search_results':
                            {
                                const { term, iteration, resultsCount, results, cumulativeResultsCount, allResults, searches, subQuestion, keywords } = eventData;
                                // Ignore initial empty placeholder snapshot to avoid a "null" entry
                                if (term === null || (resultsCount === 0 && iteration === 0)) {
                                    updateLiveSummary(searches || [], cumulativeResultsCount || 0);
                                    break;
                                }

                                stepsElement.innerHTML += `
                                    <div style=\"margin: 5px 0; padding: 12px; background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); border-radius: 6px; box-shadow: 0 1px 5px rgba(0,0,0,0.1);\">
                                        <div style=\"display: flex; align-items: center; gap: 8px; font-weight: 500;\">
                                            <span style=\"color: #28a745;\">✅</span>
                                            <span>\"${term}\"</span>
                                            <span style=\"background: rgba(255,255,255,0.8); padding: 2px 8px; border-radius: 12px; font-size: 0.9em; color: #333;\">
                                                ${resultsCount} results (total ${cumulativeResultsCount || 0})
                                            </span>
                                        </div>
                                    </div>
                                `;
                                statusElement.textContent = `📥 Received ${resultsCount} result(s) for "${term}" (iteration ${iteration}) — total ${cumulativeResultsCount || 0}`;

                                // Update structured state for the full results tree
                                if (!resultsState.byIteration[iteration]) resultsState.byIteration[iteration] = {};
                                resultsState.byIteration[iteration][term] = Array.isArray(results) ? results : [];
                                // Store metadata for this term
                                const metaKey = `${iteration}|${term}`;
                                metaMap.set(metaKey, { subQuestion: subQuestion || null, keywords: Array.isArray(keywords) ? keywords : [] });

                                // Mark this search timer as done
                                stopSearchTimer(iteration, term, 'done');

                                // Update summary and full tree
                                // Keep last searches for digest refresh convenience
                                window.__lastSearches = searches || [];
                                updateLiveSummary(window.__lastSearches, cumulativeResultsCount || 0);
                                updateFullResultsTree();
                            }
                            break;
                            
                        case 'continuation':
                            const continueGradient = eventData.shouldContinue ? 
                                'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)' : 
                                'linear-gradient(135deg, #a8e6cf 0%, #dcedc1 100%)';
                            stepsElement.innerHTML += `
                                <div style="margin: 10px 0; padding: 15px; background: ${continueGradient}; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                                    <div style="font-weight: bold; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                                        <span>${eventData.shouldContinue ? '🔄' : '✋'}</span>
                                        ${eventData.shouldContinue ? 'Continuing:' : 'Stopping:'}
                                    </div>
                                    <div style="opacity: 0.8;">${eventData.reasoning}</div>
                                </div>
                            `;
                            break;
                            
                        case 'final_response':
                            statusElement.textContent = '✅ Search completed! Displaying final response...';
                            if (stopButton) { stopButton.disabled = true; stopButton.textContent = 'Done'; }
                            stopAllTimers('done');
                            answerElement.innerHTML = `<div style="white-space: pre-wrap; line-height: 1.7;">${eventData.response}</div>`;
                            // Keep metadata visible and updated
                            metadataContent.innerHTML = `
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                                    <div style="background: white; padding: 12px; border-radius: 6px; border-left: 4px solid #007bff;">
                                        <div style="font-weight: bold; color: #007bff; margin-bottom: 4px;">Total Results</div>
                                        <div style="font-size: 1.2em; color: #333;">${eventData.totalResults}</div>
                                    </div>
                                    <div style="background: white; padding: 12px; border-radius: 6px; border-left: 4px solid #28a745;">
                                        <div style="font-weight: bold; color: #28a745; margin-bottom: 4px;">Search Iterations</div>
                                        <div style="font-size: 1.2em; color: #333;">${eventData.searchIterations}</div>
                                    </div>
                                    <div style="background: white; padding: 12px; border-radius: 6px; border-left: 4px solid #ffc107;">
                                        <div style="font-weight: bold; color: #ffc107; margin-bottom: 4px;">Completed</div>
                                        <div style="font-size: 1.1em; color: #333;">${new Date(eventData.timestamp).toLocaleTimeString()}</div>
                                    </div>
                                </div>
                            `;
                            metadataElement.style.display = 'block';
                            break;
                            
                        case 'complete':
                            statusElement.textContent = `✅ Complete! Total time: ${Math.round(eventData.executionTime)}ms`;
                            responseContainer.className = 'response-container response-success';
                            if (stopButton) { stopButton.disabled = true; stopButton.textContent = 'Done'; }
                            stopAllTimers('done');
                            // Ensure the full results tree reflects the final snapshot
                            if (Array.isArray(eventData.allResults) && eventData.allResults.length) {
                                // If we never received structured iterations, fall back to a flat section
                                const hasStructure = Object.keys(resultsState.byIteration).length > 0;
                                if (!hasStructure) {
                                    resultsState.byIteration[1] = { 'All results': eventData.allResults };
                                }
                                updateFullResultsTree();
                            }
                            break;
                            
                        case 'error':
                            statusElement.textContent = `❌ Error: ${eventData.error}`;
                            responseContainer.className = 'response-container response-error';
                            if (stopButton) { stopButton.disabled = true; stopButton.textContent = 'Error'; }
                            stopAllTimers('error');
                            stepsElement.innerHTML += `
                                <div style="margin: 10px 0; padding: 15px; background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%); border-radius: 8px; color: #721c24;">
                                    <div style="font-weight: bold; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                                        <span>❌</span> Error Occurred
                                    </div>
                                    <div>${eventData.error}</div>
                                </div>
                            `;
                            break;
                    }
                    
                } catch (parseError) {
                    console.error('Error parsing event:', parseError, event);
                }
            }
        }
        
    } catch (streamError) {
        console.error('Streaming error:', streamError);
        if (stopButton) { stopButton.disabled = true; stopButton.textContent = 'Stopped'; }
        stopAllTimers('stopped');
        if (streamError.name === 'AbortError') {
            statusElement.textContent = '⏹️ Stopped by user. Partial results are shown above.';
            // Keep existing partial results visible without switching to error theme
            responseContainer.className = 'response-container';
        } else {
            statusElement.textContent = `❌ Streaming Error: ${streamError.message}`;
            responseContainer.className = 'response-container response-error';
        }
    }
}

</script>

</body>
</html>
