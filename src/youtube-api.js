/**
 * YouTube API Integration
 * 
 * Provides functions to fetch YouTube video transcripts using OAuth2 tokens.
 * Uses YouTube Data API v3 for caption/transcript access.
 * Also includes unofficial caption endpoint for public videos.
 */

const https = require('https');
const { URL } = require('url');

/**
 * Fetch YouTube video transcript using OAuth2 token
 * 
 * @param {string} url - YouTube video URL (youtube.com, youtu.be, youtube.com/shorts)
 * @param {string} accessToken - OAuth2 access token with youtube.force-ssl scope
 * @param {Object} options - Optional parameters
 * @param {boolean} options.includeTimestamps - Return structured data with timestamps (default: false)
 * @param {string} options.language - Preferred language code (default: 'en')
 * @returns {Promise<string|Object>} - Plain text transcript or structured data if includeTimestamps=true
 * @throws {Error} - If video ID invalid, no captions available, or API error
 */
async function getYouTubeTranscript(url, accessToken, options = {}) {
  console.log('Fetching YouTube transcript for:', url);
  
  const { includeTimestamps = false, language = 'en' } = options;
  
  // Extract video ID
  const videoId = extractYouTubeVideoId(url);
  if (!videoId) {
    throw new Error('Invalid YouTube URL - could not extract video ID');
  }

  console.log('Extracted video ID:', videoId);

  // Get caption tracks for video
  const captionsUrl = `https://www.googleapis.com/youtube/v3/captions?part=snippet&videoId=${videoId}`;
  
  const captionsResponse = await makeHttpsRequest(captionsUrl, {
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Accept': 'application/json'
    }
  });

  const captionsData = JSON.parse(captionsResponse);
  
  // Check for API errors
  if (captionsData.error) {
    console.error('YouTube API error:', captionsData.error);
    throw new Error(`YouTube API error: ${captionsData.error.message || 'Unknown error'}`);
  }

  // Find available caption tracks
  const captions = captionsData.items || [];
  if (captions.length === 0) {
    throw new Error('No captions available for this video');
  }

  console.log(`Found ${captions.length} caption tracks:`, captions.map(c => ({
    language: c.snippet.language,
    name: c.snippet.name,
    kind: c.snippet.trackKind
  })));

  // Prefer requested language, fallback to English, then first available
  const preferredCaption = captions.find(c => 
    c.snippet.language === language || c.snippet.language.startsWith(language)
  ) || captions.find(c => 
    c.snippet.language === 'en' || c.snippet.language.startsWith('en')
  ) || captions[0];

  const captionId = preferredCaption.id;
  const captionLang = preferredCaption.snippet.language;
  const captionName = preferredCaption.snippet.name || captionLang;
  const captionKind = preferredCaption.snippet.trackKind; // 'standard' or 'ASR' (auto-generated)
  
  console.log(`Using caption track: ${captionLang} (${captionKind}) - ${captionName}`);

  // Download caption track
  // Note: YouTube API requires tfmt parameter for caption download
  const trackUrl = `https://www.googleapis.com/youtube/v3/captions/${captionId}?tfmt=srt`;
  
  const transcript = await makeHttpsRequest(trackUrl, {
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Accept': 'text/plain'
    }
  });

  // If timestamps requested, parse SRT to structured format
  if (includeTimestamps) {
    const segments = parseSrtToSegments(transcript);
    const metadata = {
      videoId,
      language: captionLang,
      languageName: captionName,
      trackKind: captionKind,
      isAutoGenerated: captionKind === 'ASR',
      segmentCount: segments.length,
      totalCharacters: segments.reduce((sum, s) => sum + s.text.length, 0),
      duration: segments.length > 0 ? segments[segments.length - 1].end : 0
    };
    
    console.log(`Successfully fetched transcript with timestamps (${segments.length} segments)`);
    
    return {
      text: segments.map(s => s.text).join(' '),
      segments,
      metadata
    };
  }

  // Parse SRT format to plain text
  const plainText = parseSrtToText(transcript);
  
  console.log(`Successfully fetched transcript (${plainText.length} characters)`);
  
  return plainText;
}

/**
 * Extract YouTube video ID from various URL formats
 * 
 * @param {string} url - YouTube URL
 * @returns {string|null} - Video ID or null if not found
 */
function extractYouTubeVideoId(url) {
  // Patterns for various YouTube URL formats
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/v\/|youtube\.com\/shorts\/)([a-zA-Z0-9_-]{11})/,
    /youtube\.com\/watch\?.*v=([a-zA-Z0-9_-]{11})/
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match && match[1]) {
      return match[1];
    }
  }

  return null;
}

/**
 * Parse SRT (SubRip) format to structured segments with timestamps
 * 
 * @param {string} srt - SRT format captions
 * @returns {Array<Object>} - Array of {index, start, end, startTime, endTime, text}
 */
function parseSrtToSegments(srt) {
  const segments = [];
  const blocks = srt.split(/\n\s*\n/); // Split by blank lines
  
  for (const block of blocks) {
    const lines = block.trim().split('\n');
    if (lines.length < 3) continue; // Need at least: index, timing, text
    
    // Line 1: sequence number
    const index = parseInt(lines[0], 10);
    if (isNaN(index)) continue;
    
    // Line 2: timing (HH:MM:SS,mmm --> HH:MM:SS,mmm)
    const timingMatch = lines[1].match(/(\d{2}):(\d{2}):(\d{2}),(\d{3})\s*-->\s*(\d{2}):(\d{2}):(\d{2}),(\d{3})/);
    if (!timingMatch) continue;
    
    const [_, startH, startM, startS, startMs, endH, endM, endS, endMs] = timingMatch;
    
    // Convert to seconds
    const start = parseInt(startH) * 3600 + parseInt(startM) * 60 + parseInt(startS) + parseInt(startMs) / 1000;
    const end = parseInt(endH) * 3600 + parseInt(endM) * 60 + parseInt(endS) + parseInt(endMs) / 1000;
    
    // Format for display (HH:MM:SS)
    const startTime = `${startH}:${startM}:${startS}`;
    const endTime = `${endH}:${endM}:${endS}`;
    
    // Lines 3+: caption text (may be multiple lines)
    const textLines = lines.slice(2);
    const text = textLines
      .map(line => line
        .replace(/<[^>]+>/g, '') // Remove HTML tags
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&amp;/g, '&')
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'")
        .trim()
      )
      .filter(line => line.length > 0)
      .join(' ')
      .replace(/\s+/g, ' ')
      .trim();
    
    if (text) {
      segments.push({
        index,
        start,      // seconds (float)
        end,        // seconds (float)
        startTime,  // formatted string
        endTime,    // formatted string
        duration: end - start,
        text
      });
    }
  }
  
  return segments;
}

/**
 * Parse SRT (SubRip) format to plain text
 * Removes sequence numbers, timestamps, and formatting
 * 
 * @param {string} srt - SRT format captions
 * @returns {string} - Plain text transcript
 */
function parseSrtToText(srt) {
  const segments = parseSrtToSegments(srt);
  return segments.map(s => s.text).join(' ').replace(/\s+/g, ' ').trim();
}

/**
 * Make HTTPS request and return response body as string
 * 
 * @param {string} url - Request URL
 * @param {Object} options - Request options (method, headers, etc.)
 * @returns {Promise<string>} - Response body
 * @throws {Error} - If request fails or returns non-2xx status
 */
function makeHttpsRequest(url, options = {}) {
  return new Promise((resolve, reject) => {
    const urlObj = new URL(url);
    
    const reqOptions = {
      hostname: urlObj.hostname,
      path: urlObj.pathname + urlObj.search,
      method: options.method || 'GET',
      headers: options.headers || {}
    };

    const req = https.request(reqOptions, (res) => {
      let data = '';
      
      res.on('data', chunk => {
        data += chunk;
      });
      
      res.on('end', () => {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          resolve(data);
        } else {
          reject(new Error(`HTTP ${res.statusCode}: ${data}`));
        }
      });
    });

    req.on('error', (err) => {
      reject(new Error(`Request failed: ${err.message}`));
    });

    if (options.body) {
      req.write(options.body);
    }

    req.end();
  });
}

/**
 * Create Webshare proxy configuration for YouTube requests
 * Uses rotating residential proxies to avoid YouTube's IP blocks on AWS
 * 
 * @param {string} username - Webshare proxy username
 * @param {string} password - Webshare proxy password
 * @returns {Object} - Proxy configuration for https.Agent
 */
function createWebshareProxyAgent(username, password) {
  if (!username || !password) {
    return null;
  }
  
  // Webshare proxy URL format: http://username-rotate:password@p.webshare.io:80/
  // The "-rotate" suffix enables IP rotation on each request
  const proxyUrl = `http://${username}-rotate:${password}@p.webshare.io:80/`;
  
  console.log(`Using Webshare proxy: ${username}-rotate@p.webshare.io`);
  
  // https-proxy-agent v7+ uses named exports
  const { HttpsProxyAgent } = require('https-proxy-agent');
  return new HttpsProxyAgent(proxyUrl);
}

/**
 * Make HTTPS request with optional proxy support
 * 
 * @param {string} url - Request URL
 * @param {Object} options - Request options
 * @param {Object} options.headers - Request headers
 * @param {string} options.method - HTTP method (GET, POST, etc.)
 * @param {string} options.body - Request body (for POST requests)
 * @param {Object} options.agent - HTTPS agent (for proxy support)
 * @returns {Promise<string>} - Response body
 */
function makeHttpsRequestWithProxy(url, options = {}) {
  return new Promise(async (resolve, reject) => {
    const usingProxy = !!options.agent;
    const maxRedirects = 5;
    
    const makeRequest = (requestUrl, useProxy = true, redirectCount = 0) => {
      return new Promise((resolveReq, rejectReq) => {
        if (redirectCount >= maxRedirects) {
          rejectReq(new Error(`Too many redirects (${maxRedirects})`));
          return;
        }
        
        const urlObj = new URL(requestUrl);
        const reqOptions = {
          hostname: urlObj.hostname,
          path: urlObj.pathname + urlObj.search,
          method: options.method || 'GET',
          headers: options.headers || {},
          agent: (useProxy && options.agent) ? options.agent : undefined
        };
        
        // Prevent connection keep-alive when using rotating proxies
        if (useProxy && options.agent) {
          reqOptions.headers['Connection'] = 'close';
        }

        const req = https.request(reqOptions, (res) => {
          // Handle redirects (301, 302, 303, 307, 308)
          if (res.statusCode >= 300 && res.statusCode < 400) {
            const location = res.headers.location || res.headers.Location;
            if (location) {
              console.log(`Following redirect ${res.statusCode}: ${location.substring(0, 100)}...`);
              
              // Handle relative URLs
              let redirectUrl;
              if (location.startsWith('http://') || location.startsWith('https://')) {
                redirectUrl = location;
              } else if (location.startsWith('//')) {
                redirectUrl = urlObj.protocol + location;
              } else if (location.startsWith('/')) {
                redirectUrl = `${urlObj.protocol}//${urlObj.host}${location}`;
              } else {
                const basePath = urlObj.pathname.substring(0, urlObj.pathname.lastIndexOf('/') + 1);
                redirectUrl = `${urlObj.protocol}//${urlObj.host}${basePath}${location}`;
              }
              
              // Drain response and follow redirect
              res.resume();
              makeRequest(redirectUrl, useProxy, redirectCount + 1)
                .then(resolveReq)
                .catch(rejectReq);
              return;
            } else {
              rejectReq(new Error(`HTTP ${res.statusCode} redirect with no location header`));
              return;
            }
          }
          
          let data = '';
          
          res.on('data', chunk => {
            data += chunk;
          });
          
          res.on('end', () => {
            if (res.statusCode >= 200 && res.statusCode < 300) {
              resolveReq(data);
            } else {
              // Check for Google blocking message
              if (data.includes('automated queries') || data.includes('g-recaptcha') || data.includes('sorry/index')) {
                if (usingProxy && useProxy) {
                  rejectReq(new Error(`PROXY_FAILED:HTTP ${res.statusCode}: Google blocked request (automated queries detected)`));
                } else {
                  rejectReq(new Error(`HTTP ${res.statusCode}: Google blocked request (automated queries detected)`));
                }
              } else {
                rejectReq(new Error(`HTTP ${res.statusCode}: ${data}`));
              }
            }
          });
        });

        req.on('error', (err) => {
          // Mark proxy-related errors for fallback
          if (usingProxy && useProxy && (
            err.message.includes('proxy') || 
            err.code === 'ECONNREFUSED' || 
            err.code === 'ETIMEDOUT' || 
            err.code === 'ECONNRESET' || 
            err.code === 'ENOTFOUND'
          )) {
            rejectReq(new Error(`PROXY_FAILED:${err.message}`));
          } else {
            rejectReq(new Error(`Request failed: ${err.message}`));
          }
        });

        if (options.body) {
          req.write(options.body);
        }

        req.end();
      });
    };
    
    // Try with proxy first, fallback to direct if proxy fails
    try {
      const result = await makeRequest(url, true, 0);
      resolve(result);
    } catch (error) {
      if (usingProxy && error.message.startsWith('PROXY_FAILED:')) {
        const originalError = error.message.replace('PROXY_FAILED:', '');
        console.log(`⚠️ YouTube API proxy failed (${originalError}), retrying direct connection...`);
        try {
          const result = await makeRequest(url, false, 0);
          console.log(`✅ YouTube API direct connection successful`);
          resolve(result);
        } catch (retryError) {
          reject(new Error(`Both proxy and direct connection failed: ${retryError.message}`));
        }
      } else {
        reject(error);
      }
    }
  });
}

/**
 * Fetch YouTube transcript using InnerTube API (youtube-transcript-api approach)
 * This is the most reliable method for public videos, works around AWS IP blocks
 * 
 * Based on: https://github.com/jdepoix/youtube-transcript-api
 * 
 * @param {string} videoId - YouTube video ID
 * @param {Object} options - Optional parameters
 * @param {string} options.language - Preferred language code (default: 'en')
 * @param {string} options.proxyUsername - Webshare proxy username (required for AWS)
 * @param {string} options.proxyPassword - Webshare proxy password (required for AWS)
 * @param {boolean} options.includeTimestamps - Return structured data with timestamps
 * @returns {Promise<string|Object>} - Transcript text or structured data
 * @throws {Error} - If transcript unavailable or request blocked
 */
async function getYouTubeTranscriptViaInnerTube(videoId, options = {}) {
  const {
    language = 'en',
    proxyUsername,
    proxyPassword,
    includeTimestamps = false
  } = options;
  
  console.log(`Fetching transcript via InnerTube for ${videoId} (language: ${language})`);
  
  // Create proxy agent if credentials provided
  const proxyAgent = createWebshareProxyAgent(proxyUsername, proxyPassword);
  
  try {
    // Step 1: Fetch YouTube video page HTML to extract InnerTube API key
    const watchUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const watchHtml = await makeHttpsRequestWithProxy(watchUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Accept-Language': 'en-US,en;q=0.9'
      },
      agent: proxyAgent
    });
    
    // Step 2: Extract INNERTUBE_API_KEY from HTML
    const apiKeyMatch = watchHtml.match(/"INNERTUBE_API_KEY":\s*"([a-zA-Z0-9_-]+)"/);
    if (!apiKeyMatch) {
      // Check for IP block indicators
      if (watchHtml.includes('g-recaptcha')) {
        throw new Error('Request blocked by YouTube - IP may be blocked (try using Webshare proxy)');
      }
      throw new Error('Could not extract InnerTube API key from page');
    }
    
    const apiKey = apiKeyMatch[1];
    console.log(`Extracted InnerTube API key: ${apiKey.substring(0, 8)}...`);
    
    // Step 3: Call InnerTube player endpoint
    const innerTubeUrl = `https://www.youtube.com/youtubei/v1/player?key=${apiKey}`;
    const innerTubeBody = JSON.stringify({
      context: {
        client: {
          clientName: 'ANDROID',
          clientVersion: '20.10.38'
        }
      },
      videoId: videoId
    });
    
    const innerTubeResponse = await makeHttpsRequestWithProxy(innerTubeUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Accept-Language': 'en-US,en;q=0.9'
      },
      body: innerTubeBody,
      agent: proxyAgent
    });
    
    const innerTubeData = JSON.parse(innerTubeResponse);
    
    // Step 4: Extract captions JSON from InnerTube response
    // Debug: Log the structure to understand what's available
    if (!innerTubeData.captions) {
      console.log(`⚠️ No captions object in InnerTube response for ${videoId}`);
      throw new Error('No captions available for this video');
    }
    
    const captionsRenderer = innerTubeData.captions.playerCaptionsTracklistRenderer;
    if (!captionsRenderer) {
      console.log(`⚠️ No playerCaptionsTracklistRenderer in captions for ${videoId}`);
      console.log(`Available captions keys: ${Object.keys(innerTubeData.captions).join(', ')}`);
      throw new Error('No captions available for this video');
    }
    
    if (!captionsRenderer.captionTracks || captionsRenderer.captionTracks.length === 0) {
      console.log(`⚠️ captionTracks is empty or missing for ${videoId}`);
      console.log(`playerCaptionsTracklistRenderer keys: ${Object.keys(captionsRenderer).join(', ')}`);
      throw new Error('No captions available for this video');
    }
    
    const captionTracks = captionsRenderer.captionTracks;
    console.log(`Found ${captionTracks.length} caption tracks`);
    
    // Find caption track for requested language
    let selectedTrack = captionTracks.find(track => track.languageCode === language);
    
    // Fallback to English if requested language not found
    if (!selectedTrack && language !== 'en') {
      console.log(`Language ${language} not found, falling back to English`);
      selectedTrack = captionTracks.find(track => track.languageCode === 'en');
    }
    
    // Use first available track if no match
    if (!selectedTrack) {
      selectedTrack = captionTracks[0];
      console.log(`Using first available track: ${selectedTrack.languageCode}`);
    }
    
    // Step 5: Fetch transcript from baseUrl
    const transcriptUrl = selectedTrack.baseUrl.replace('&fmt=srv3', '');
    console.log(`Fetching transcript from: ${transcriptUrl.substring(0, 80)}...`);
    
    const transcriptXml = await makeHttpsRequestWithProxy(transcriptUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Accept': 'text/xml'
      },
      agent: proxyAgent
    });
    
    // Step 6: Parse XML transcript
    if (includeTimestamps) {
      // Return structured data with timestamps
      return parseTranscriptXmlWithTimestamps(transcriptXml, videoId, selectedTrack);
    } else {
      // Return plain text
      return parseTranscriptXmlToText(transcriptXml);
    }
    
  } catch (error) {
    console.error(`InnerTube transcript fetch failed for ${videoId}:`, error.message);
    throw error;
  }
}

/**
 * Parse YouTube transcript XML to plain text
 * 
 * @param {string} xml - Transcript XML data
 * @returns {string} - Plain text transcript
 */
function parseTranscriptXmlToText(xml) {
  // Extract text from <text> tags: <text start="0.0" dur="2.5">Caption text</text>
  const textMatches = xml.match(/<text[^>]*>([^<]+)<\/text>/g);
  
  if (!textMatches || textMatches.length === 0) {
    throw new Error('No captions found in transcript XML');
  }
  
  const transcript = textMatches
    .map(match => {
      const textMatch = match.match(/>([^<]+)</);
      if (!textMatch) return '';
      
      return decodeHtmlEntities(textMatch[1]).trim();
    })
    .filter(text => text.length > 0)
    .join(' ')
    .replace(/\s+/g, ' ')
    .trim();
  
  return transcript;
}

/**
 * Parse YouTube transcript XML to structured data with timestamps
 * 
 * @param {string} xml - Transcript XML data
 * @param {string} videoId - Video ID
 * @param {Object} trackInfo - Caption track metadata
 * @returns {Object} - Structured transcript data
 */
function parseTranscriptXmlWithTimestamps(xml, videoId, trackInfo) {
  const textMatches = xml.match(/<text[^>]*start="([^"]+)"[^>]*dur="([^"]+)"[^>]*>([^<]+)<\/text>/g);
  
  if (!textMatches || textMatches.length === 0) {
    throw new Error('No captions found in transcript XML');
  }
  
  const snippets = textMatches.map(match => {
    const startMatch = match.match(/start="([^"]+)"/);
    const durMatch = match.match(/dur="([^"]+)"/);
    const textMatch = match.match(/>([^<]+)</);
    
    const start = startMatch ? parseFloat(startMatch[1]) : 0;
    const duration = durMatch ? parseFloat(durMatch[1]) : 0;
    const text = textMatch ? decodeHtmlEntities(textMatch[1]).trim() : '';
    
    return { text, start, duration };
  });
  
  return {
    snippets,
    videoId,
    language: trackInfo.name?.runs?.[0]?.text || trackInfo.languageCode,
    languageCode: trackInfo.languageCode,
    isGenerated: trackInfo.kind === 'asr'
  };
}

/**
 * Decode HTML entities in text
 * 
 * @param {string} text - Text with HTML entities
 * @returns {string} - Decoded text
 */
function decodeHtmlEntities(text) {
  return text
    .replace(/&#39;/g, "'")
    .replace(/&quot;/g, '"')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&#(\d+);/g, (match, dec) => String.fromCharCode(dec));
}

/**
 * Fetch YouTube video transcript from public videos (no OAuth required)
 * Uses YouTube's timedtext endpoint which is available for public videos
 * 
 * @param {string} videoId - YouTube video ID
 * @param {string} language - Language code (default: 'en')
 * @returns {Promise<string>} - Plain text transcript
 * @throws {Error} - If no captions available or fetch fails
 */
async function getPublicYouTubeTranscript(videoId, language = 'en') {
  try {
    // Try to get the transcript from YouTube's timedtext endpoint
    // This endpoint provides auto-generated and manual captions for public videos
    const timedtextUrl = `https://www.youtube.com/api/timedtext?lang=${language}&v=${videoId}`;
    
    console.log(`Fetching public transcript for ${videoId} (language: ${language})`);
    
    const xmlData = await makeHttpsRequest(timedtextUrl, {
      headers: {
        'Accept': 'text/xml',
        'User-Agent': 'Mozilla/5.0'
      }
    });
    
    // Parse XML to extract text
    // Format: <transcript><text start="0.0" dur="2.5">Caption text</text>...</transcript>
    const textMatches = xmlData.match(/<text[^>]*>([^<]+)<\/text>/g);
    
    if (!textMatches || textMatches.length === 0) {
      throw new Error('No captions found in response');
    }
    
    // Extract text content and decode HTML entities
    const transcript = textMatches
      .map(match => {
        const textMatch = match.match(/>([^<]+)</);
        if (!textMatch) return '';
        
        return textMatch[1]
          .replace(/&#39;/g, "'")
          .replace(/&quot;/g, '"')
          .replace(/&amp;/g, '&')
          .replace(/&lt;/g, '<')
          .replace(/&gt;/g, '>')
          .trim();
      })
      .filter(text => text.length > 0)
      .join(' ')
      .replace(/\s+/g, ' ')
      .trim();
    
    console.log(`✅ Fetched public transcript for ${videoId} (${transcript.length} chars)`);
    return transcript;
    
  } catch (error) {
    console.error(`Failed to fetch public transcript for ${videoId}:`, error.message);
    throw error;
  }
}

/**
 * Fetch YouTube transcript using Selenium (fallback method)
 * Works when API methods fail - higher success rate but slower
 * 
 * @param {string} videoId - YouTube video ID
 * @param {Object} options - Optional parameters
 * @param {boolean} options.includeTimestamps - Return structured data with timestamps
 * @param {string} options.language - Preferred language code (default: 'en')
 * @param {boolean} options.interactive - Keep browser open for manual intervention
 * @returns {Promise<string|Object>} - Transcript text or structured data
 */
async function getYouTubeTranscriptViaSelenium(videoId, options = {}) {
  const IS_LAMBDA = !!process.env.AWS_FN;
  
  if (IS_LAMBDA) {
    throw new Error('Selenium caption scraping is not available on AWS Lambda. Use InnerTube or OAuth API instead.');
  }
  
  const {
    includeTimestamps = false,
    language = 'en',
    interactive = false
  } = options;
  
  console.log(`🤖 [Selenium] Fetching YouTube captions for ${videoId} (language: ${language}, timestamps: ${includeTimestamps})`);
  
  try {
    const { scrapeYouTubeCaptions } = require('./scrapers/youtube-caption-scraper');
    
    const result = await scrapeYouTubeCaptions(videoId, {
      language,
      includeTimestamps,
      interactive,
      timeout: 30000
    });
    
    if (result.error) {
      throw new Error(result.error);
    }
    
    if (includeTimestamps && result.segments) {
      // Return structured data with timestamps
      return {
        videoId: result.videoId,
        title: result.title,
        text: result.text,
        language: result.language,
        method: result.method,
        snippets: result.segments.map(seg => ({
          timestamp: seg.timestamp,
          text: seg.text
        })),
        metadata: {
          captionCount: result.captionCount,
          source: 'selenium-dom'
        }
      };
    } else {
      // Return plain text
      return result.text;
    }
    
  } catch (error) {
    console.error(`❌ [Selenium] Caption scraping failed:`, error.message);
    throw error;
  }
}

module.exports = {
  getYouTubeTranscript,
  getYouTubeTranscriptViaInnerTube,
  getPublicYouTubeTranscript,
  getYouTubeTranscriptViaSelenium,
  extractYouTubeVideoId,
  parseSrtToText,
  parseSrtToSegments,
  createWebshareProxyAgent
};
